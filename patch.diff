diff --git a/include/fix8/ff/cycle.h b/include/fix8/ff/cycle.h
index 81bbee2..b83d186 100644
--- a/include/fix8/ff/cycle.h
+++ b/include/fix8/ff/cycle.h
@@ -23,7 +23,6 @@
  *
  */
 
-
 /* machine-dependent cycle counters code. Needs to be inlined. */
 
 /***************************************************************************/
@@ -59,19 +58,19 @@
    AC_HEADER_TIME
    AC_CHECK_HEADERS([sys/time.h c_asm.h intrinsics.h mach/mach_time.h])
 
-   AC_CHECK_TYPE([hrtime_t],[AC_DEFINE(HAVE_HRTIME_T, 1, [Define to 1 if hrtime_t is defined in <sys/time.h>])],,[#if HAVE_SYS_TIME_H
-#include <sys/time.h>
-#endif])
+   AC_CHECK_TYPE([hrtime_t],[AC_DEFINE(HAVE_HRTIME_T, 1, [Define to 1 if hrtime_t is
+defined in <sys/time.h>])],,[#if HAVE_SYS_TIME_H #include <sys/time.h> #endif])
 
-   AC_CHECK_FUNCS([gethrtime read_real_time time_base_to_time clock_gettime mach_absolute_time])
+   AC_CHECK_FUNCS([gethrtime read_real_time time_base_to_time clock_gettime
+mach_absolute_time])
 
    dnl Cray UNICOS _rtc() (real-time clock) intrinsic
    AC_MSG_CHECKING([for _rtc intrinsic])
    rtc_ok=yes
    AC_TRY_LINK([#ifdef HAVE_INTRINSICS_H
 #include <intrinsics.h>
-#endif], [_rtc()], [AC_DEFINE(HAVE__RTC,1,[Define if you have the UNICOS _rtc() intrinsic.])], [rtc_ok=no])
-   AC_MSG_RESULT($rtc_ok)
+#endif], [_rtc()], [AC_DEFINE(HAVE__RTC,1,[Define if you have the UNICOS _rtc()
+intrinsic.])], [rtc_ok=no]) AC_MSG_RESULT($rtc_ok)
 
    dnl ---------------------------------------------------------------------
 */
@@ -97,11 +96,8 @@
 #endif
 #endif
 
-#define INLINE_ELAPSED(INL) static INL double elapsed(ticks t1, ticks t0) \
-{									  \
-     return (double)t1 - (double)t0;					  \
-}
-
+#define INLINE_ELAPSED(INL) \
+    static INL double elapsed(ticks t1, ticks t0) { return (double)t1 - (double)t0; }
 
 /*----------------------------------------------------------------*/
 /* Solaris */
@@ -117,11 +113,11 @@ INLINE_ELAPSED(inline)
 
 /*----------------------------------------------------------------*/
 /* AIX v. 4+ routines to read the real-time clock or time-base register */
-#if defined(HAVE_READ_REAL_TIME) && defined(HAVE_TIME_BASE_TO_TIME) && !defined(HAVE_TICK_COUNTER)
+#if defined(HAVE_READ_REAL_TIME) && defined(HAVE_TIME_BASE_TO_TIME) && \
+    !defined(HAVE_TICK_COUNTER)
 typedef timebasestruct_t ticks;
 
-static __inline ticks getticks(void)
-{
+static __inline ticks getticks(void) {
     ticks t;
     read_real_time(&t, TIMEBASE_SZ);
     return t;
@@ -142,11 +138,13 @@ static __inline double elapsed(ticks t1, ticks t0) /* time in nanoseconds */
 /*
  * PowerPC ``cycle'' counter using the time base register.
  */
-#if ((((defined(__GNUC__) && (defined(__powerpc__) || defined(__ppc__))) || (defined(__MWERKS__) && defined(macintosh)))) || (defined(__IBM_GCC_ASM) && (defined(__powerpc__) || defined(__ppc__))))  && !defined(HAVE_TICK_COUNTER)
+#if ((((defined(__GNUC__) && (defined(__powerpc__) || defined(__ppc__))) ||     \
+       (defined(__MWERKS__) && defined(macintosh)))) ||                         \
+     (defined(__IBM_GCC_ASM) && (defined(__powerpc__) || defined(__ppc__)))) && \
+    !defined(HAVE_TICK_COUNTER)
 typedef unsigned long long ticks;
 
-static __inline__ ticks getticks(void)
-{
+static __inline__ ticks getticks(void) {
     unsigned int tbl, tbu0, tbu1;
 
     do {
@@ -165,7 +163,8 @@ INLINE_ELAPSED(__inline__)
 
 /* MacOS/Mach (Darwin) time-base register interface (unlike UpTime,
    from Carbon, requires no additional libraries to be linked). */
-#if defined(HAVE_MACH_ABSOLUTE_TIME) && defined(HAVE_MACH_MACH_TIME_H) && !defined(HAVE_TICK_COUNTER)
+#if defined(HAVE_MACH_ABSOLUTE_TIME) && defined(HAVE_MACH_MACH_TIME_H) && \
+    !defined(HAVE_TICK_COUNTER)
 #include <mach/mach_time.h>
 typedef uint64_t ticks;
 #define getticks mach_absolute_time
@@ -177,11 +176,11 @@ INLINE_ELAPSED(__inline__)
 /*
  * Pentium cycle counter
  */
-#if (defined(__GNUC__) || defined(__ICC)) && defined(__i386__)  && !defined(HAVE_TICK_COUNTER)
+#if (defined(__GNUC__) || defined(__ICC)) && defined(__i386__) && \
+    !defined(HAVE_TICK_COUNTER)
 typedef unsigned long long ticks;
 
-static __inline__ ticks getticks(void)
-{
+static __inline__ ticks getticks(void) {
     ticks ret;
 
     __asm__ __volatile__("rdtsc" : "=A"(ret));
@@ -199,11 +198,11 @@ INLINE_ELAPSED(__inline__)
 /*
  * ARM cycle counter (Mauro Mulatero)
  */
-#if (defined(__GNUC__) || defined(__ICC)) && defined(__linux__) && defined(__arm__) && !defined(HAVE_TICK_COUNTER)
+#if (defined(__GNUC__) || defined(__ICC)) && defined(__linux__) && defined(__arm__) && \
+    !defined(HAVE_TICK_COUNTER)
 
 typedef unsigned long ticks;
 
-
 /****
   Come indicato nella documentazione ARM il registro P15 non pu√≤ essere
   letto in user space e di conseguenza bisogna appoggiarsi alle API esposte
@@ -243,8 +242,7 @@ static inline unsigned long ff_read_ccnt(void)
   - CLOCK_TRACE_FREQ
   - CLOCK_TRACE
   **/
-static __inline__ ticks getticks(void)
-{
+static __inline__ ticks getticks(void) {
     ticks ret = 0;
     timespec time_tick;
     if (clock_gettime(CLOCK_MONOTONIC_RAW, &time_tick) == 0) {
@@ -264,15 +262,15 @@ INLINE_ELAPSED(__inline__)
  March 2011, Marco Aldinucci, aldinuc@di.unito.it
 ----------------------------------------------------------------*/
 
-#if (defined(_MSC_VER) || defined(__INTEL_COMPILER)) && defined(_WIN32) && !defined(HAVE_TICK_COUNTER)
+#if (defined(_MSC_VER) || defined(__INTEL_COMPILER)) && defined(_WIN32) && \
+    !defined(HAVE_TICK_COUNTER)
 #pragma once
-#include <windows.h>
 #include <intrin.h>
+#include <windows.h>
 #pragma intrinsic(__rdtsc)
 typedef unsigned __int64 ticks;
 
-static __forceinline ticks getticks(void)
-{
+static __forceinline ticks getticks(void) {
     // LARGE_INTEGER time;
     // QueryPerformanceCounter(&time);
     // return (long long) time.QuadPart;
@@ -290,8 +288,7 @@ INLINE_ELAPSED(inline)
 typedef LARGE_INTEGER ticks;
 #define RDTSC __asm __emit 0fh __asm __emit 031h /* hack for VC++ 5.0 */
 
-static __inline ticks getticks(void)
-{
+static __inline ticks getticks(void) {
     ticks retval;
 
     __asm {
@@ -302,8 +299,7 @@ static __inline ticks getticks(void)
     return retval;
 }
 
-static __inline double elapsed(ticks t1, ticks t0)
-{  
+static __inline double elapsed(ticks t1, ticks t0) {
     return (double)t1.QuadPart - (double)t0.QuadPart;
 }
 
@@ -315,11 +311,11 @@ static __inline double elapsed(ticks t1, ticks t0)
 /*
  * X86-64 cycle counter
  */
-#if (defined(__GNUC__) || defined(__ICC) || defined(__SUNPRO_C)) && defined(__x86_64__)  && !defined(HAVE_TICK_COUNTER)
+#if (defined(__GNUC__) || defined(__ICC) || defined(__SUNPRO_C)) && \
+    defined(__x86_64__) && !defined(HAVE_TICK_COUNTER)
 typedef unsigned long long ticks;
 
-static __inline__ ticks getticks(void)
-{
+static __inline__ ticks getticks(void) {
     unsigned a, d;
     asm volatile("rdtsc" : "=a"(a), "=d"(d));
     return ((ticks)a) | (((ticks)d) << 32);
@@ -335,8 +331,7 @@ INLINE_ELAPSED(__inline__)
    option (grrr). */
 #if defined(__PGI) && defined(__x86_64__) && !defined(HAVE_TICK_COUNTER)
 typedef unsigned long long ticks;
-static ticks getticks(void)
-{
+static ticks getticks(void) {
     asm(" rdtsc; shl    $0x20,%rdx; mov    %eax,%eax; or     %rdx,%rax;    ");
 }
 INLINE_ELAPSED(__inline__)
@@ -344,7 +339,8 @@ INLINE_ELAPSED(__inline__)
 #endif
 
 /* Visual C++, courtesy of Dirk Michaelis */
-#if _MSC_VER >= 1400 && (defined(_M_AMD64) || defined(_M_X64)) && !defined(HAVE_TICK_COUNTER)
+#if _MSC_VER >= 1400 && (defined(_M_AMD64) || defined(_M_X64)) && \
+    !defined(HAVE_TICK_COUNTER)
 
 #include <intrin.h>
 #pragma intrinsic(__rdtsc)
@@ -361,14 +357,12 @@ INLINE_ELAPSED(__inline)
  */
 
 /* intel's icc/ecc compiler */
-#if (defined(__EDG_VERSION) || defined(__ECC)) && defined(__ia64__) && !defined(HAVE_TICK_COUNTER)
+#if (defined(__EDG_VERSION) || defined(__ECC)) && defined(__ia64__) && \
+    !defined(HAVE_TICK_COUNTER)
 typedef unsigned long ticks;
 #include <ia64intrin.h>
 
-static __inline__ ticks getticks(void)
-{
-     return __getReg(_IA64_REG_AR_ITC);
-}
+static __inline__ ticks getticks(void) { return __getReg(_IA64_REG_AR_ITC); }
 
 INLINE_ELAPSED(__inline__)
 
@@ -379,8 +373,7 @@ INLINE_ELAPSED(__inline__)
 #if defined(__GNUC__) && defined(__ia64__) && !defined(HAVE_TICK_COUNTER)
 typedef unsigned long ticks;
 
-static __inline__ ticks getticks(void)
-{
+static __inline__ ticks getticks(void) {
     ticks ret;
 
     __asm__ __volatile__("mov %0=ar.itc" : "=r"(ret));
@@ -397,8 +390,7 @@ INLINE_ELAPSED(__inline__)
 #include <machine/sys/inline.h>
 typedef unsigned long ticks;
 
-static inline ticks getticks(void)
-{
+static inline ticks getticks(void) {
     ticks ret;
 
     ret = _Asm_mov_from_ar(_AREG_ITC);
@@ -417,11 +409,11 @@ typedef unsigned __int64 ticks;
 #ifdef __cplusplus
 extern "C"
 #endif
-ticks __getReg(int whichReg);
+    ticks
+    __getReg(int whichReg);
 #pragma intrinsic(__getReg)
 
-static __inline ticks getticks(void)
-{
+static __inline ticks getticks(void) {
     volatile ticks temp;
     temp = __getReg(3116);
     return temp;
@@ -440,8 +432,7 @@ INLINE_ELAPSED(inline)
 typedef unsigned long ticks;
 
 #ifdef __GNUC__
-static __inline__ ticks getticks(void)
-{
+static __inline__ ticks getticks(void) {
     ticks ret;
 
     __asm__ __volatile__("mfctl 16, %0" : "=r"(ret));
@@ -450,8 +441,7 @@ static __inline__ ticks getticks(void)
 }
 #else
 #include <machine/inline.h>
-static inline unsigned long getticks(void)
-{
+static inline unsigned long getticks(void) {
     ticks ret;
     _MFCTL(16, ret);
     return ret;
@@ -468,8 +458,7 @@ INLINE_ELAPSED(inline)
 #if defined(__GNUC__) && defined(__s390__) && !defined(HAVE_TICK_COUNTER)
 typedef unsigned long long ticks;
 
-static __inline__ ticks getticks(void)
-{
+static __inline__ ticks getticks(void) {
     ticks cycles;
     __asm__("stck 0(%0)" : : "a"(&(cycles)) : "memory", "cc");
     return cycles;
@@ -487,8 +476,7 @@ INLINE_ELAPSED(__inline__)
  */
 typedef unsigned int ticks;
 
-static __inline__ ticks getticks(void)
-{
+static __inline__ ticks getticks(void) {
     unsigned long cc;
     __asm__ __volatile__("rpcc %0" : "=r"(cc));
     return (cc & 0xFFFFFFFF);
@@ -503,8 +491,7 @@ INLINE_ELAPSED(__inline__)
 #if defined(__GNUC__) && defined(__sparc_v9__) && !defined(HAVE_TICK_COUNTER)
 typedef unsigned long ticks;
 
-static __inline__ ticks getticks(void)
-{
+static __inline__ ticks getticks(void) {
     ticks ret;
     __asm__ __volatile__("rd %%tick, %0" : "=r"(ret));
     return ret;
@@ -516,12 +503,12 @@ INLINE_ELAPSED(__inline__)
 #endif
 
 /*----------------------------------------------------------------*/
-#if (defined(__DECC) || defined(__DECCXX)) && defined(__alpha) && defined(HAVE_C_ASM_H) && !defined(HAVE_TICK_COUNTER)
+#if (defined(__DECC) || defined(__DECCXX)) && defined(__alpha) && \
+    defined(HAVE_C_ASM_H) && !defined(HAVE_TICK_COUNTER)
 #include <c_asm.h>
 typedef unsigned int ticks;
 
-static __inline ticks getticks(void)
-{
+static __inline ticks getticks(void) {
     unsigned long cc;
     cc = asm("rpcc %v0");
     return (cc & 0xFFFFFFFF);
@@ -533,18 +520,17 @@ INLINE_ELAPSED(__inline)
 #endif
 /*----------------------------------------------------------------*/
 /* SGI/Irix */
-#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_SGI_CYCLE) && !defined(HAVE_TICK_COUNTER)
+#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_SGI_CYCLE) && \
+    !defined(HAVE_TICK_COUNTER)
 typedef struct timespec ticks;
 
-static inline ticks getticks(void)
-{
+static inline ticks getticks(void) {
     struct timespec t;
     clock_gettime(CLOCK_SGI_CYCLE, &t);
     return t;
 }
 
-static inline double elapsed(ticks t1, ticks t0)
-{
+static inline double elapsed(ticks t1, ticks t0) {
     return ((double)t1.tv_sec - (double)t0.tv_sec) * 1.0E9 +
            ((double)t1.tv_nsec - (double)t0.tv_nsec);
 }
@@ -571,18 +557,16 @@ INLINE_ELAPSED(inline)
 /* MIPS ZBus */
 #if HAVE_MIPS_ZBUS_TIMER
 #if defined(__mips__) && !defined(HAVE_TICK_COUNTER)
+#include <fcntl.h>
 #include <sys/mman.h>
 #include <unistd.h>
-#include <fcntl.h>
 
 typedef uint64_t ticks;
 
-static inline ticks getticks(void)
-{
+static inline ticks getticks(void) {
     static uint64_t* addr = 0;
 
-  if (addr == 0)
-  {
+    if (addr == 0) {
         uint32_t rq_addr = 0x10030000;
         int fd;
         int pgsize;
@@ -610,5 +594,14 @@ INLINE_ELAPSED(inline)
 #endif
 #endif /* HAVE_MIPS_ZBUS_TIMER */
 
+/* MacOS Apple Silicon support */
+#if defined(__APPLE__) && defined(__aarch64__)
+#include <mach/mach_time.h>
+typedef uint64_t ticks;
+
+static inline ticks getticks(void) { return mach_absolute_time(); }
+
+static inline double elapsed(ticks t1, ticks t0) { return (double)(t1 - t0); }
+#endif
 
 #endif /* FF_CYCLE_H */
diff --git a/include/fix8/ff/mpmc/asm/atomic.h b/include/fix8/ff/mpmc/asm/atomic.h
index c33a62d..7030ed5 100644
--- a/include/fix8/ff/mpmc/asm/atomic.h
+++ b/include/fix8/ff/mpmc/asm/atomic.h
@@ -4,20 +4,16 @@
  *
  */
 
-#ifndef FF_ASM_GENERIC_ATOMIC_H
-#define FF_ASM_GENERIC_ATOMIC_H
-/*
- * Copyright (C) 2005 Silicon Graphics, Inc.
- *  Christoph Lameter <clameter@sgi.com>
- *
- * Allows to provide arch independent atomic definitions without the need to
- * edit all arch specific atomic.h files.
- */
+#ifndef __ATOMIC_H
+#define __ATOMIC_H
 
+#include <fix8/ff/platforms/platform.h>
 
-//#include <asm/types.h>
+#if defined(__APPLE__)
+#include <fix8/ff/mpmc/asm/macos/atomic.h>
+#elif defined(__linux__) || defined(__FreeBSD__)
 
-#if defined(__linux__) || defined(__FreeBSD__) || defined(__APPLE__)
+// #include <asm/types.h>
 
 #if defined(__linux__) || defined(__FreeBSD__)
 #ifdef __i386__
@@ -61,76 +57,64 @@
 
 #if (BITS_PER_LONG == 64)
 
-
 typedef atomic64_t atomic_long_t;
 
 #define ATOMIC_LONG_INIT(i) ATOMIC64_INIT(i)
 
-static inline unsigned long atomic_long_read(atomic_long_t *l)
-{
+static inline unsigned long atomic_long_read(atomic_long_t *l) {
     atomic64_t *v = (atomic64_t *)l;
 
     return atomic64_read(v);
 }
 
-static inline void atomic_long_set(atomic_long_t *l, long i)
-{
+static inline void atomic_long_set(atomic_long_t *l, long i) {
     atomic64_t *v = (atomic64_t *)l;
 
     atomic64_set(v, i);
 }
 
-static inline void atomic_long_inc(atomic_long_t *l)
-{
+static inline void atomic_long_inc(atomic_long_t *l) {
     atomic64_t *v = (atomic64_t *)l;
 
     atomic64_inc(v);
 }
 
-static inline unsigned long atomic_long_inc_return(atomic_long_t *l)
-{
+static inline unsigned long atomic_long_inc_return(atomic_long_t *l) {
     atomic64_t *v = (atomic64_t *)l;
 
     return atomic64_inc_return(v);
 }
 
-static inline void atomic_long_dec(atomic_long_t *l)
-{
+static inline void atomic_long_dec(atomic_long_t *l) {
     atomic64_t *v = (atomic64_t *)l;
 
     atomic64_dec(v);
 }
 
-static inline unsigned long atomic_long_dec_return(atomic_long_t *l)
-{
+static inline unsigned long atomic_long_dec_return(atomic_long_t *l) {
     atomic64_t *v = (atomic64_t *)l;
 
     return atomic64_dec_return(v);
 }
 
-static inline void atomic_long_add(long i, atomic_long_t *l)
-{
+static inline void atomic_long_add(long i, atomic_long_t *l) {
     atomic64_t *v = (atomic64_t *)l;
 
     atomic64_add(i, v);
 }
 
-static inline void atomic_long_sub(long i, atomic_long_t *l)
-{
+static inline void atomic_long_sub(long i, atomic_long_t *l) {
     atomic64_t *v = (atomic64_t *)l;
 
     atomic64_sub(i, v);
 }
 
-
-static inline unsigned long atomic_long_add_unless(atomic_long_t *l, long a, long u)
-{
+static inline unsigned long atomic_long_add_unless(atomic_long_t *l, long a, long u) {
     atomic64_t *v = (atomic64_t *)l;
 
     return atomic64_add_unless(v, a, u);
 }
 
-
 #define atomic_long_cmpxchg(l, old, new) \
     (atomic64_cmpxchg((atomic64_t *)(l), (old), (new)))
 
@@ -140,78 +124,69 @@ typedef atomic_t atomic_long_t;
 
 #define ATOMIC_LONG_INIT(i) ATOMIC_INIT(i)
 
-static inline unsigned long atomic_long_read(atomic_long_t *l)
-{
+static inline unsigned long atomic_long_read(atomic_long_t *l) {
     atomic_t *v = (atomic_t *)l;
 
     return atomic_read(v);
 }
 
-static inline void atomic_long_set(atomic_long_t *l, long i)
-{
+static inline void atomic_long_set(atomic_long_t *l, long i) {
     atomic_t *v = (atomic_t *)l;
 
     atomic_set(v, i);
 }
 
-static inline void atomic_long_inc(atomic_long_t *l)
-{
+static inline void atomic_long_inc(atomic_long_t *l) {
     atomic_t *v = (atomic_t *)l;
 
     atomic_inc(v);
 }
 
-static inline unsigned long atomic_long_inc_return(atomic_long_t *l)
-{
+static inline unsigned long atomic_long_inc_return(atomic_long_t *l) {
     atomic_t *v = (atomic_t *)l;
 
     return atomic_inc_return(v);
 }
 
-static inline void atomic_long_dec(atomic_long_t *l)
-{
+static inline void atomic_long_dec(atomic_long_t *l) {
     atomic_t *v = (atomic_t *)l;
 
     atomic_dec(v);
 }
 
-static inline unsigned long atomic_long_dec_return(atomic_long_t *l)
-{
+static inline unsigned long atomic_long_dec_return(atomic_long_t *l) {
     atomic_t *v = (atomic_t *)l;
 
     return atomic_dec_return(v);
 }
 
-
-static inline void atomic_long_add(long i, atomic_long_t *l)
-{
+static inline void atomic_long_add(long i, atomic_long_t *l) {
     atomic_t *v = (atomic_t *)l;
 
     atomic_add(i, v);
 }
 
-static inline void atomic_long_sub(long i, atomic_long_t *l)
-{
+static inline void atomic_long_sub(long i, atomic_long_t *l) {
     atomic_t *v = (atomic_t *)l;
 
     atomic_sub(i, v);
 }
 
-static inline unsigned long atomic_long_add_unless(atomic_long_t *l, long a, long u)
-{
+static inline unsigned long atomic_long_add_unless(atomic_long_t *l, long a, long u) {
     atomic_t *v = (atomic_t *)l;
 
     return atomic_add_unless(v, a, u);
 }
 
-#define atomic_long_cmpxchg(l, old, new) \
-  (atomic_cmpxchg((atomic_t *)(l), (old), (new)))
+#define atomic_long_cmpxchg(l, old, new) (atomic_cmpxchg((atomic_t *)(l), (old), (new)))
 
 #endif
 
 #elif defined(_WIN32)
 // TODO: Atomic operations to be redefined on top of C++11 atomic ops
-typedef __declspec(align(4 /* 32 bit */)) struct { volatile long counter; } atomic_t;
+typedef __declspec(align(4 /* 32 bit */)) struct {
+    volatile long counter;
+} atomic_t;
 typedef atomic_t atomic_long_t;
 #define atomic_set(v, i) (((v)->counter) = (i))
 #define atomic_read(v) ((v)->counter)
@@ -226,7 +201,6 @@ static inline void atomic_long_inc(atomic_long_t *v) {
     _InterlockedIncrement(&v->counter);
 }
 static inline long atomic_long_inc_return(atomic_long_t *v) {
-
     return _InterlockedIncrement(&v->counter);
     // return _InterlockedExchangeAdd((long volatile*)l, 1) + 1;
 }
@@ -235,9 +209,31 @@ static inline long atomic_long_inc_return(atomic_long_t *v) {
 static inline void atomic_long_dec(atomic_long_t *v) {
     _InterlockedDecrement(&v->counter);
 }
+static inline long atomic_long_dec_return(atomic_long_t *v) {
+    return _InterlockedDecrement(&v->counter);
+}
 
-#endif
+#pragma intrinsic(_InterlockedExchangeAdd)
+static inline void atomic_long_add(long i, atomic_long_t *v) {
+    _InterlockedExchangeAdd(&v->counter, i);
+}
+static inline void atomic_long_sub(long i, atomic_long_t *v) {
+    _InterlockedExchangeAdd(&v->counter, -i);
+}
 
-#endif /* FF_ASM_GENERIC_ATOMIC_H */
+#pragma intrinsic(_InterlockedCompareExchange)
+static inline long atomic_long_add_unless(atomic_long_t *v, long a, long u) {
+    long c, old;
+    c = atomic_read(v);
+    for (;;) {
+        if (c == u) break;
+        old = c;
+        c = _InterlockedCompareExchange(&v->counter, c + a, c);
+        if (c == old) break;
+    }
+    return c != u;
+}
 
+#endif
 
+#endif /* __ATOMIC_H */
diff --git a/include/fix8/ff/platforms/platform.h b/include/fix8/ff/platforms/platform.h
index e32e61a..0fa7127 100755
--- a/include/fix8/ff/platforms/platform.h
+++ b/include/fix8/ff/platforms/platform.h
@@ -32,16 +32,25 @@
 #else
 // #warning "Redefining posix_memalign"
 #include <errno.h>
-inline static int posix_memalign(void **memptr, size_t alignment, size_t size)
-{
-    if (memptr && (*memptr = malloc(size))) return 0;
-    else return (ENOMEM);
+inline static int posix_memalign(void **memptr, size_t alignment, size_t size) {
+    if (memptr && (*memptr = malloc(size)))
+        return 0;
+    else
+        return (ENOMEM);
 }
 #endif
-#endif
 
+// Add WMB macro for macOS
+#define WMB() __sync_synchronize()
 
+// Add PAUSE macro for macOS
+#if defined(__x86_64__) || defined(__i386__)
+#define PAUSE() __asm__ __volatile__("pause" ::: "memory")
+#else
+#define PAUSE() __asm__ __volatile__("yield" ::: "memory")
+#endif
 
+#endif
 
 #if defined(_WIN32)
 #pragma unmanaged
@@ -57,7 +66,6 @@ inline static int posix_memalign(void **memptr, size_t alignment, size_t size)
 // Thread specific storage
 #define __thread __declspec(thread)
 
-
 // Only x86 and x86_64 are currently supported for Windows OS
 INLINE void WMB() {}
 INLINE void PAUSE() {}
@@ -65,17 +73,12 @@ INLINE void PAUSE() {}
 #include <BaseTsd.h>
 typedef SSIZE_T ssize_t;
 
-INLINE static int posix_memalign(void **memptr,size_t alignment, size_t sz)
-{
+INLINE static int posix_memalign(void **memptr, size_t alignment, size_t sz) {
     *memptr = _aligned_malloc(sz, alignment);
     return (!memptr);
 }
 
-
-INLINE static void posix_memalign_free(void* mem)
-{
-    _aligned_free(mem);
-}
+INLINE static void posix_memalign_free(void *mem) { _aligned_free(mem); }
 
 // Other
 
@@ -87,18 +90,14 @@ typedef unsigned long useconds_t;
 #define sleep(SECS) Sleep(SECS)
 
 INLINE static int usleep(unsigned long microsecs) {
-  if (microsecs > 100000)
-    /* At least 100 mS. Typical best resolution is ~ 15ms */
+    if (microsecs > 100000) /* At least 100 mS. Typical best resolution is ~ 15ms */
         Sleep(microsecs / 1000);
-  else
-    {
+    else {
         /* Use Sleep for the largest part, and busy-loop for the rest. */
         static double frequency;
-      if (frequency == 0)
-        {
+        if (frequency == 0) {
             LARGE_INTEGER freq;
-          if (!QueryPerformanceFrequency (&freq))
-            {
+            if (!QueryPerformanceFrequency(&freq)) {
                 /* Cannot use QueryPerformanceCounter. */
                 Sleep(microsecs / 1000);
                 return 0;
@@ -109,22 +108,17 @@ INLINE static int usleep(unsigned long microsecs) {
         int sleep_part = (int)(microsecs) / 1000 - 10;
         LARGE_INTEGER before;
         QueryPerformanceCounter(&before);
-      long long expected_counter = before.QuadPart +
-expected_counter_difference;
-      if (sleep_part > 0)
-        Sleep (sleep_part);
-      for (;;)
-        {
+        long long expected_counter = before.QuadPart + expected_counter_difference;
+        if (sleep_part > 0) Sleep(sleep_part);
+        for (;;) {
             LARGE_INTEGER after;
             QueryPerformanceCounter(&after);
-          if (after.QuadPart >= expected_counter)
-            break;
+            if (after.QuadPart >= expected_counter) break;
         }
     }
     return (0);
 }
 
-
 // #define __TICKS2WAIT 1000
 #define random rand
 #define srandom srand
@@ -145,20 +139,17 @@ struct timeval {
 #endif
 */
 
-struct timezone
-{
+struct timezone {
     int tz_minuteswest; /* minutes W of Greenwich */
     int tz_dsttime;     /* type of dst correction */
 };
 
-INLINE static int gettimeofday(struct timeval *tv, struct timezone *tz)
-{
+INLINE static int gettimeofday(struct timeval *tv, struct timezone *tz) {
     FILETIME ft;
     unsigned __int64 tmpres = 0;
     static int tzflag;
 
-  if (NULL != tv)
-  {
+    if (NULL != tv) {
         GetSystemTimeAsFileTime(&ft);
 
         tmpres |= ft.dwHighDateTime;
@@ -172,10 +163,8 @@ INLINE static int gettimeofday(struct timeval *tv, struct timezone *tz)
         tv->tv_usec = (long)(tmpres % 1000000UL);
     }
 
-  if (NULL != tz)
-  {
-    if (!tzflag)
-    {
+    if (NULL != tz) {
+        if (!tzflag) {
             _tzset();
             tzflag++;
         }
@@ -209,11 +198,9 @@ struct rusage {
     long ru_nivcsw;          /* involuntary context switches */
 };
 
-
 // sys/uio.h
 
-struct iovec
-{
+struct iovec {
     void *iov_base;
     size_t iov_len;
 };
@@ -223,15 +210,11 @@ struct iovec
 // #endif
 #include <algorithm>
 #elif defined(__GNUC__) && (defined(__linux__) || defined(__APPLE__))
-#include <sys/time.h>
-#include <unistd.h>
-#include <stdlib.h>
 #include <pthread.h>
 #include <stdlib.h>
-inline static void posix_memalign_free(void* mem)
-{
-    free(mem);
-}
+#include <sys/time.h>
+#include <unistd.h>
+inline static void posix_memalign_free(void* mem) { free(mem); }
 // #define __TICKS2WAIT 1000
 
 #else
@@ -239,5 +222,3 @@ inline static void posix_memalign_free(void* mem)
 #endif
 
 #endif /* FF_PLATFORM_HPP */
-
-
diff --git a/include/fix8/field.hpp b/include/fix8/field.hpp
index fb10f1e..9c956b7 100644
--- a/include/fix8/field.hpp
+++ b/include/fix8/field.hpp
@@ -37,8 +37,8 @@ HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
 #ifndef FIX8_FIELD_HPP_
 #define FIX8_FIELD_HPP_
 
-#include <Poco/Timestamp.h>
 #include <Poco/DateTime.h>
+#include <Poco/Timestamp.h>
 
 //-------------------------------------------------------------------------------------------------
 namespace FIX8 {
diff --git a/include/fix8/thread.hpp b/include/fix8/thread.hpp
index c4b6ca7..041616d 100644
--- a/include/fix8/thread.hpp
+++ b/include/fix8/thread.hpp
@@ -6,31 +6,34 @@ Fix8 is released under the GNU LESSER GENERAL PUBLIC LICENSE Version 3.
 Fix8 Open Source FIX Engine.
 Copyright (C) 2010-19 David L. Dight <fix@fix8.org>
 
-Fix8 is free software: you can  redistribute it and / or modify  it under the  terms of the
-GNU Lesser General  Public License as  published  by the Free  Software Foundation,  either
-version 3 of the License, or (at your option) any later version.
-
-Fix8 is distributed in the hope  that it will be useful, but WITHOUT ANY WARRANTY;  without
-even the  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-
-You should  have received a copy of the GNU Lesser General Public  License along with Fix8.
-If not, see <http://www.gnu.org/licenses/>.
-
-BECAUSE THE PROGRAM IS  LICENSED FREE OF  CHARGE, THERE IS NO  WARRANTY FOR THE PROGRAM, TO
-THE EXTENT  PERMITTED  BY  APPLICABLE  LAW.  EXCEPT WHEN  OTHERWISE  STATED IN  WRITING THE
-COPYRIGHT HOLDERS AND/OR OTHER PARTIES  PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY
-KIND,  EITHER EXPRESSED   OR   IMPLIED,  INCLUDING,  BUT   NOT  LIMITED   TO,  THE  IMPLIED
-WARRANTIES  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO
-THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE,
-YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-IN NO EVENT UNLESS REQUIRED  BY APPLICABLE LAW  OR AGREED TO IN  WRITING WILL ANY COPYRIGHT
-HOLDER, OR  ANY OTHER PARTY  WHO MAY MODIFY  AND/OR REDISTRIBUTE  THE PROGRAM AS  PERMITTED
-ABOVE,  BE  LIABLE  TO  YOU  FOR  DAMAGES,  INCLUDING  ANY  GENERAL, SPECIAL, INCIDENTAL OR
-CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT
-NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR
-THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH
-HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+Fix8 is free software: you can  redistribute it and / or modify  it under the  terms of
+the GNU Lesser General  Public License as  published  by the Free  Software Foundation,
+either version 3 of the License, or (at your option) any later version.
+
+Fix8 is distributed in the hope  that it will be useful, but WITHOUT ANY WARRANTY;
+without even the  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+PURPOSE.
+
+You should  have received a copy of the GNU Lesser General Public  License along with
+Fix8. If not, see <http://www.gnu.org/licenses/>.
+
+BECAUSE THE PROGRAM IS  LICENSED FREE OF  CHARGE, THERE IS NO  WARRANTY FOR THE PROGRAM,
+TO THE EXTENT  PERMITTED  BY  APPLICABLE  LAW.  EXCEPT WHEN  OTHERWISE  STATED IN
+WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES  PROVIDE THE PROGRAM "AS IS" WITHOUT
+WARRANTY OF ANY KIND,  EITHER EXPRESSED   OR   IMPLIED,  INCLUDING,  BUT   NOT  LIMITED
+TO,  THE  IMPLIED WARRANTIES  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
+CORRECTION.
+
+IN NO EVENT UNLESS REQUIRED  BY APPLICABLE LAW  OR AGREED TO IN  WRITING WILL ANY
+COPYRIGHT HOLDER, OR  ANY OTHER PARTY  WHO MAY MODIFY  AND/OR REDISTRIBUTE  THE PROGRAM
+AS  PERMITTED ABOVE,  BE  LIABLE  TO  YOU  FOR  DAMAGES,  INCLUDING  ANY  GENERAL,
+SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
+THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE
+OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH
+ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
 
 */
 //-----------------------------------------------------------------------------------------
@@ -44,15 +47,15 @@ HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
 #include <pthread.h>
 #include <signal.h>
 #elif (FIX8_THREAD_SYSTEM == FIX8_THREAD_STDTHREAD)
-#include<thread>
 #include <mutex>
+#include <thread>
 #endif
 
 //----------------------------------------------------------------------------------------
-namespace FIX8
-{
+namespace FIX8 {
 
-template<typename T> using f8_atomic = std::atomic <T>;
+template <typename T>
+using f8_atomic = std::atomic<T>;
 
 #if (FIX8_THREAD_SYSTEM == FIX8_THREAD_STDTHREAD)
 using thread_id_t = std::thread::id;
@@ -62,8 +65,7 @@ template<typename T> using f8_atomic = std::atomic <T>;
 
 //----------------------------------------------------------------------------------------
 /// pthread wrapper abstract base
-class _f8_threadcore
-{
+class _f8_threadcore {
 #if (FIX8_THREAD_SYSTEM == FIX8_THREAD_PTHREAD)
     pthread_attr_t _attr;
     pthread_t _tid;
@@ -73,16 +75,19 @@ class _f8_threadcore
 
 #if (FIX8_THREAD_SYSTEM == FIX8_THREAD_PTHREAD)
     template <typename T>
-	static void *_run(void *what) { return reinterpret_cast<void *>((*static_cast<T *>(what))()); }
+    static void* _run(void* what) {
+        return reinterpret_cast<void*>((*static_cast<T*>(what))());
+    }
 #else
     template <typename T>
-	static void _run(void *what) { (*static_cast<T *>(what))(); }
+    static void _run(void* what) {
+        (*static_cast<T*>(what))();
+    }
 #endif
 
    protected:
     template <typename T>
-	int _start(void *sub)
-	{
+    int _start(void* sub) {
 #if (FIX8_THREAD_SYSTEM == FIX8_THREAD_PTHREAD)
         return pthread_create(&_tid, &_attr, _run<T>, sub);
 #elif (FIX8_THREAD_SYSTEM == FIX8_THREAD_STDTHREAD)
@@ -95,8 +100,7 @@ public:
     /*! Ctor. */
     _f8_threadcore()
 #if (FIX8_THREAD_SYSTEM == FIX8_THREAD_PTHREAD)
-		: _attr(), _tid()
-	{
+        : _attr(), _tid() {
         if (pthread_attr_init(&_attr))
             throw f8_threadException("pthread_attr_init failure");
 #else
@@ -105,8 +109,7 @@ public:
     }
 
     /// Dtor.
-	virtual ~_f8_threadcore()
-	{
+    virtual ~_f8_threadcore() {
         join();
 #if (FIX8_THREAD_SYSTEM == FIX8_THREAD_PTHREAD)
         pthread_attr_destroy(&_attr);
@@ -123,10 +126,10 @@ public:
 
     /*! Join the thread.
       \return result of join */
-	virtual int join(int timeoutInMs = 0)
-	{
+    virtual int join(int timeoutInMs = 0) {
 #if (FIX8_THREAD_SYSTEM == FIX8_THREAD_PTHREAD)
-		return getid() != get_threadid() ? pthread_join(_tid, nullptr) ? -1 : 0 : -1; // prevent self-join
+        return getid() != get_threadid() ? pthread_join(_tid, nullptr) ? -1 : 0
+                                         : -1;  // prevent self-join
 #elif (FIX8_THREAD_SYSTEM == FIX8_THREAD_STDTHREAD)
         if (_thread.get() && _thread->joinable() && getid() != get_threadid())
             _thread->join();
@@ -140,8 +143,7 @@ public:
 #ifdef __APPLE__
     int yield() const { return sched_yield(); }
 #else
-	int yield() const
-	{
+    int yield() const {
 #if (FIX8_THREAD_SYSTEM == FIX8_THREAD_PTHREAD)
         return pthread_yield();
 #elif (FIX8_THREAD_SYSTEM == FIX8_THREAD_STDTHREAD)
@@ -154,8 +156,7 @@ public:
 
     /*! Get the thread's thread ID.
       \return the thread id */
-	thread_id_t get_threadid() const
-	{
+    thread_id_t get_threadid() const {
 #if (FIX8_THREAD_SYSTEM == FIX8_THREAD_PTHREAD)
         return _tid;
 #elif (FIX8_THREAD_SYSTEM == FIX8_THREAD_STDTHREAD)
@@ -165,8 +166,7 @@ public:
 
     /*! Get the thread's thread ID. Static version.
       \return the thread id */
-	static thread_id_t getid()
-	{
+    static thread_id_t getid() {
 #if (FIX8_THREAD_SYSTEM == FIX8_THREAD_PTHREAD)
         return pthread_self();
 #elif (FIX8_THREAD_SYSTEM == FIX8_THREAD_STDTHREAD)
@@ -177,8 +177,7 @@ public:
     /*! f8_thread equivalence operator.
       \param that the other thread id
       \return true if the threads are equal */
-	bool operator==(const _f8_threadcore& that) const
-	{
+    bool operator==(const _f8_threadcore& that) const {
 #if (FIX8_THREAD_SYSTEM == FIX8_THREAD_PTHREAD)
         return pthread_equal(_tid, that._tid);
 #else
@@ -189,8 +188,7 @@ public:
     /*! f8_thread inequivalence operator.
       \param that the other thread id
       \return true if the threads are unequal */
-	bool operator!=(const _f8_threadcore& that) const
-	{
+    bool operator!=(const _f8_threadcore& that) const {
 #if (FIX8_THREAD_SYSTEM == FIX8_THREAD_PTHREAD)
         return !pthread_equal(_tid, that._tid);
 #else
@@ -203,20 +201,25 @@ public:
 
 //----------------------------------------------------------------------------------------
 /// Thread cancellation token
-class f8_thread_cancellation_token
-{
+class f8_thread_cancellation_token {
     f8_atomic<int> _stop_requested, _thread_state;
 
    public:
     /// ctor
-	f8_thread_cancellation_token() { _stop_requested = 0; _thread_state = Unknown; }
+    f8_thread_cancellation_token() {
+        _stop_requested = 0;
+        _thread_state = Unknown;
+    }
 
     /*! check if a stop has been requested
       \return true if stop requested */
     bool stop_requested() const { return _stop_requested == 1; }
 
     /// Tell the thread to stop
-	void request_stop() { _thread_state = Stopping; _stop_requested = 1; }
+    void request_stop() {
+        _thread_state = Stopping;
+        _stop_requested = 1;
+    }
 
     /*! check if a stop has been requested
       \return true if stop requested */
@@ -239,38 +242,40 @@ public:
 };
 
 //----------------------------------------------------------------------------------------
-/// Thread wrapper. Ctor provides T instance and specifies ptr to member to call or defaults to operator()
+/// Thread wrapper. Ctor provides T instance and specifies ptr to member to call or
+/// defaults to operator()
 /*! \tparam T class call thread entry functor */
 template <typename T>
-class f8_thread : public _f8_threadcore
-{
-	class _helper
-	{
+class f8_thread : public _f8_threadcore {
+    class _helper {
         T& _what;
         int (T::*_method)();
         f8_thread_cancellation_token& (T::*_cancellation_token_method)();
 
        public:
-		_helper(T& what, int (T::*method)(), f8_thread_cancellation_token& (T::*cancellation_token_method)())
-			: _what(what), _method(method), _cancellation_token_method(cancellation_token_method) {}
-		int operator()()
-		{
-			try
-			{
-				cancellation_token().thread_state(f8_thread_cancellation_token::Running);
+        _helper(T& what, int (T::*method)(),
+                f8_thread_cancellation_token& (T::*cancellation_token_method)())
+            : _what(what),
+              _method(method),
+              _cancellation_token_method(cancellation_token_method) {}
+        int operator()() {
+            try {
+                cancellation_token().thread_state(
+                    f8_thread_cancellation_token::Running);
                 const int ret((_what.*_method)());
-				cancellation_token().thread_state(f8_thread_cancellation_token::Stopped);
+                cancellation_token().thread_state(
+                    f8_thread_cancellation_token::Stopped);
                 return ret;
-			}
-			catch(const std::exception&)
-			{
-				cancellation_token().thread_state(f8_thread_cancellation_token::Stopped);
+            } catch (const std::exception&) {
+                cancellation_token().thread_state(
+                    f8_thread_cancellation_token::Stopped);
                 throw;
             }
         }
-		f8_thread_cancellation_token& cancellation_token() { return (_what.*_cancellation_token_method)(); }
+        f8_thread_cancellation_token& cancellation_token() {
+            return (_what.*_cancellation_token_method)();
         }
-	_sub;
+    } _sub;
 
    public:
     /*! Ctor. Reference to object, functor version.
@@ -278,7 +283,8 @@ public:
       \param method reference to entry point method
       \param cancellation_token_method pointer to cancellation_token */
     f8_thread(std::reference_wrapper<T> what, int (T::*method)() = &T::operator(),
-		f8_thread_cancellation_token& (T::*cancellation_token_method)()=&T::cancellation_token)
+              f8_thread_cancellation_token& (T::*cancellation_token_method)() =
+                  &T::cancellation_token)
         : _sub(what, method, cancellation_token_method) {}
 
     /// Dtor.
@@ -296,13 +302,11 @@ public:
 //----------------------------------------------------------------------------------------
 /// generic pthread_mutex wrapper
 #if (FIX8_THREAD_SYSTEM == FIX8_THREAD_PTHREAD)
-class f8_mutex
-{
+class f8_mutex {
     pthread_mutex_t _pmutex;
 
    public:
-	f8_mutex()
-	{
+    f8_mutex() {
         if (pthread_mutex_init(&_pmutex, 0))
             throw f8Exception("pthread_mutex_init failed");
     }
@@ -313,54 +317,51 @@ public:
     bool try_lock() { return pthread_mutex_trylock(&_pmutex) == 0; }
     void unlock() { pthread_mutex_unlock(&_pmutex); }
 };
+#elif (FIX8_THREAD_SYSTEM == FIX8_THREAD_STDTHREAD)
+using f8_mutex = std::mutex;
 #endif
+
 //----------------------------------------------------------------------------------------
 /// generic spin_lock wrapper
 
 #ifdef __APPLE__
-// A simple spinlock that spins up to 100K times and then does a sched_yield to back-off.
-// unlock() could just set _lock to false BUT that assumes that the spinlock was locked
-// to begin with, which may not be the case.  Therefore this implementation has the
-// advantage of causing your thread to spin if you try to unlock something that is
-// not locked, which I would think is a logic error that the caller should fix.
-// The choice of 100K was arbitrary.  The right way to set that parameter would be
-// to keep track of how big x gets before thread starvation occurs and use that number.
-// That number is going to be target- and use-case-dependent  though.
-class f8_spin_lock
-{
+// A simple spinlock that spins up to 100K times and then does a sched_yield to
+// back-off. unlock() could just set _lock to false BUT that assumes that the spinlock
+// was locked to begin with, which may not be the case.  Therefore this implementation
+// has the advantage of causing your thread to spin if you try to unlock something that
+// is not locked, which I would think is a logic error that the caller should fix. The
+// choice of 100K was arbitrary.  The right way to set that parameter would be to keep
+// track of how big x gets before thread starvation occurs and use that number. That
+// number is going to be target- and use-case-dependent  though.
+class f8_spin_lock {
     bool _isLocked;
+
    public:
     f8_spin_lock() : _isLocked(false) {}
     ~f8_spin_lock() {}
 
-	void lock()
-	{
+    void lock() {
 #if __cplusplus >= 201703L
         int x = 0;
 #else
         register int x = 0;
 #endif
-		while(!__sync_bool_compare_and_swap(&_isLocked, false, true))
-		{
-			if(++x >= 100000)
-			{
+        while (!__sync_bool_compare_and_swap(&_isLocked, false, true)) {
+            if (++x >= 100000) {
                 x = 0;
                 sched_yield();
             }
         }
     }
     bool try_lock() { return _isLocked; }
-	void unlock()
-	{
+    void unlock() {
 #if __cplusplus >= 201703L
         int x = 0;
 #else
         register int x = 0;
 #endif
-		while(!__sync_bool_compare_and_swap(&_isLocked, true, false))
-		{
-			if(++x >= 100000)
-			{
+        while (!__sync_bool_compare_and_swap(&_isLocked, true, false)) {
+            if (++x >= 100000) {
                 x = 0;
                 sched_yield();
             }
@@ -369,13 +370,11 @@ public:
 };
 #else
 #if (FIX8_THREAD_SYSTEM == FIX8_THREAD_PTHREAD)
-class f8_spin_lock
-{
+class f8_spin_lock {
     pthread_spinlock_t _psl;
 
    public:
-	f8_spin_lock()
-	{
+    f8_spin_lock() {
         if (pthread_spin_init(&_psl, PTHREAD_PROCESS_PRIVATE))
             throw f8Exception("pthread_spin_init failed");
     }
@@ -387,9 +386,7 @@ public:
     void unlock() { pthread_spin_unlock(&_psl); }
 };
 #elif (FIX8_THREAD_SYSTEM == FIX8_THREAD_STDTHREAD)
-using f8_mutex = std::mutex;
-class f8_spin_lock
-{
+class f8_spin_lock {
     std::atomic_flag _sl
 #ifndef _MSC_VER
         = ATOMIC_FLAG_INIT
@@ -397,10 +394,10 @@ class f8_spin_lock
         ;
 
    public:
-    f8_spin_lock()
-	 {
+    f8_spin_lock() {
 #ifdef _MSC_VER
-		 _sl.clear(std::memory_order_relaxed); // = ATOMIC_FLAG_INIT # does not compile under vs2013
+        _sl.clear(std::memory_order_relaxed);  // = ATOMIC_FLAG_INIT # does not compile
+                                               // under vs2013
 #endif
     }
     ~f8_spin_lock() = default;
@@ -413,18 +410,15 @@ public:
 #endif  //__APPLE__
 
 template <typename T>
-class f8_scoped_lock_impl
-{
+class f8_scoped_lock_impl {
     T* _local_mutex = nullptr;
     bool _disabled = false;
 
    public:
     f8_scoped_lock_impl() = default;
     f8_scoped_lock_impl(T& mutex) { acquire(mutex); }
-    f8_scoped_lock_impl(T& mutex, bool disable) : _disabled(disable)
-    {
-        if (!_disabled)
-            acquire(mutex);
+    f8_scoped_lock_impl(T& mutex, bool disable) : _disabled(disable) {
+        if (!_disabled) acquire(mutex);
     }
 
     ~f8_scoped_lock_impl() { release(); }
@@ -432,24 +426,19 @@ public:
     f8_scoped_lock_impl(const f8_scoped_lock_impl&) = delete;
     f8_scoped_lock_impl& operator=(const f8_scoped_lock_impl&) = delete;
 
-    void acquire(T& mutex)
-    {
+    void acquire(T& mutex) {
         mutex.lock();
         _local_mutex = &mutex;
     }
 
-    bool try_acquire(T& mutex)
-    {
+    bool try_acquire(T& mutex) {
         bool result(mutex.try_lock());
-        if (result)
-            _local_mutex = &mutex;
+        if (result) _local_mutex = &mutex;
         return result;
     }
 
-    void release()
-    {
-        if (!_disabled && _local_mutex)
-        {
+    void release() {
+        if (!_disabled && _local_mutex) {
             _local_mutex->unlock();
             _local_mutex = nullptr;
         }
@@ -458,10 +447,11 @@ public:
 
 using f8_scoped_lock = f8_scoped_lock_impl<f8_mutex>;
 using f8_scoped_spin_lock = f8_scoped_lock_impl<f8_spin_lock>;
-template<typename T> using dthread = f8_thread<T>;
+template <typename T>
+using dthread = f8_thread<T>;
 using _dthreadcore = _f8_threadcore;
 using dthread_cancellation_token = f8_thread_cancellation_token;
 
-} // FIX8
+}  // namespace FIX8
 
 #endif  // FIX8_THREAD_HPP_
diff --git a/runtime/message.cpp b/runtime/message.cpp
index 13d0fbe..295ff63 100644
--- a/runtime/message.cpp
+++ b/runtime/message.cpp
@@ -6,36 +6,40 @@ Fix8 is released under the GNU LESSER GENERAL PUBLIC LICENSE Version 3.
 Fix8 Open Source FIX Engine.
 Copyright (C) 2010-19 David L. Dight <fix@fix8.org>
 
-Fix8 is free software: you can  redistribute it and / or modify  it under the  terms of the
-GNU Lesser General  Public License as  published  by the Free  Software Foundation,  either
-version 3 of the License, or (at your option) any later version.
-
-Fix8 is distributed in the hope  that it will be useful, but WITHOUT ANY WARRANTY;  without
-even the  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-
-You should  have received a copy of the GNU Lesser General Public  License along with Fix8.
-If not, see <http://www.gnu.org/licenses/>.
-
-BECAUSE THE PROGRAM IS  LICENSED FREE OF  CHARGE, THERE IS NO  WARRANTY FOR THE PROGRAM, TO
-THE EXTENT  PERMITTED  BY  APPLICABLE  LAW.  EXCEPT WHEN  OTHERWISE  STATED IN  WRITING THE
-COPYRIGHT HOLDERS AND/OR OTHER PARTIES  PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY
-KIND,  EITHER EXPRESSED   OR   IMPLIED,  INCLUDING,  BUT   NOT  LIMITED   TO,  THE  IMPLIED
-WARRANTIES  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO
-THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE,
-YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-IN NO EVENT UNLESS REQUIRED  BY APPLICABLE LAW  OR AGREED TO IN  WRITING WILL ANY COPYRIGHT
-HOLDER, OR  ANY OTHER PARTY  WHO MAY MODIFY  AND/OR REDISTRIBUTE  THE PROGRAM AS  PERMITTED
-ABOVE,  BE  LIABLE  TO  YOU  FOR  DAMAGES,  INCLUDING  ANY  GENERAL, SPECIAL, INCIDENTAL OR
-CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT
-NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR
-THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH
-HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+Fix8 is free software: you can  redistribute it and / or modify  it under the  terms of
+the GNU Lesser General  Public License as  published  by the Free  Software Foundation,
+either version 3 of the License, or (at your option) any later version.
+
+Fix8 is distributed in the hope  that it will be useful, but WITHOUT ANY WARRANTY;
+without even the  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+PURPOSE.
+
+You should  have received a copy of the GNU Lesser General Public  License along with
+Fix8. If not, see <http://www.gnu.org/licenses/>.
+
+BECAUSE THE PROGRAM IS  LICENSED FREE OF  CHARGE, THERE IS NO  WARRANTY FOR THE PROGRAM,
+TO THE EXTENT  PERMITTED  BY  APPLICABLE  LAW.  EXCEPT WHEN  OTHERWISE  STATED IN
+WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES  PROVIDE THE PROGRAM "AS IS" WITHOUT
+WARRANTY OF ANY KIND,  EITHER EXPRESSED   OR   IMPLIED,  INCLUDING,  BUT   NOT  LIMITED
+TO,  THE  IMPLIED WARRANTIES  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
+CORRECTION.
+
+IN NO EVENT UNLESS REQUIRED  BY APPLICABLE LAW  OR AGREED TO IN  WRITING WILL ANY
+COPYRIGHT HOLDER, OR  ANY OTHER PARTY  WHO MAY MODIFY  AND/OR REDISTRIBUTE  THE PROGRAM
+AS  PERMITTED ABOVE,  BE  LIABLE  TO  YOU  FOR  DAMAGES,  INCLUDING  ANY  GENERAL,
+SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
+THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE
+OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH
+ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
 
 */
 //-----------------------------------------------------------------------------------------
-#include "precomp.hpp"
 #include <fix8/f8includes.hpp>
+
+#include "precomp.hpp"
 #if defined FIX8_CODECTIMING
 #include <fix8/f8measure.hpp>
 #endif
@@ -51,27 +55,21 @@ stop_watch Message::_codec_timings(Message::sw__max);
 unsigned MessageBase::_tabsize = defaults::tabsize;
 
 //-------------------------------------------------------------------------------------------------
-unsigned MessageBase::extract_header(const f8String& from, char *len, char *mtype)
-{
+unsigned MessageBase::extract_header(const f8String &from, char *len, char *mtype) {
     const char *dptr(from.data());
     const unsigned flen(static_cast<unsigned>(from.size()));
     char tag[MAX_MSGTYPE_FIELD_LEN], val[FIX8_MAX_FLD_LENGTH];
     unsigned s_offset(0), result;
 
-	if ((result = extract_element(dptr, flen, tag, val)))
-	{
-		if (*tag != '8')
-			return 0;
+    if ((result = extract_element(dptr, flen, tag, val))) {
+        if (*tag != '8') return 0;
         s_offset += result;
-		if ((result = extract_element(dptr + s_offset, flen - s_offset, tag, len)))
-		{
-			if (*tag != '9')
-				return 0;
+        if ((result = extract_element(dptr + s_offset, flen - s_offset, tag, len))) {
+            if (*tag != '9') return 0;
             s_offset += result;
-			if ((result = extract_element(dptr + s_offset, flen - s_offset, tag, mtype)))
-			{
-				if (*tag != '3' || *(tag + 1) != '5')
-					return 0;
+            if ((result =
+                     extract_element(dptr + s_offset, flen - s_offset, tag, mtype))) {
+                if (*tag != '3' || *(tag + 1) != '5') return 0;
                 s_offset += result;
             }
         }
@@ -80,32 +78,30 @@ unsigned MessageBase::extract_header(const f8String& from, char *len, char *mtyp
 }
 
 //-------------------------------------------------------------------------------------------------
-unsigned MessageBase::extract_trailer(const f8String& from, f8String& chksum)
-{
+unsigned MessageBase::extract_trailer(const f8String &from, f8String &chksum) {
     f8String tag;
     return extract_element(from.data() + from.size() - 7, 6, tag, chksum);
 }
 
 //-------------------------------------------------------------------------------------------------
-unsigned MessageBase::decode(const f8String& from, unsigned s_offset, unsigned ignore, bool permissive_mode)
-{
+unsigned MessageBase::decode(const f8String &from, unsigned s_offset, unsigned ignore,
+                             bool permissive_mode) {
     const unsigned fsize(static_cast<unsigned>(from.size()) - ignore), npos(0xffffffff);
     unsigned pos(static_cast<unsigned>(_pos.size())), last_valid_pos(npos);
     const char *dptr(from.data());
     char tag[FIX8_MAX_FLD_LENGTH], val[FIX8_MAX_FLD_LENGTH];
     size_t last_valid_offset(0);
 
-	for (unsigned result; s_offset <= fsize && (result = extract_element(dptr + s_offset, fsize - s_offset, tag, val));)
-	{
+    for (unsigned result;
+         s_offset <= fsize &&
+         (result = extract_element(dptr + s_offset, fsize - s_offset, tag, val));) {
         unsigned short tv(fast_atoi<unsigned short>(tag));
+        std::cout << "DEBUG tv: " << tv << std::endl;
         Presence::const_iterator itr(_fp.get_presence().find(tv));
-		if (itr == _fp.get_presence().end())
-		{
+        if (itr == _fp.get_presence().end()) {
         unknown_field:
-			if (permissive_mode)
-			{
-				if (last_valid_pos == npos)
-				{
+            if (permissive_mode) {
+                if (last_valid_pos == npos) {
                     last_valid_pos = pos;
                     last_valid_offset = s_offset;
                 }
@@ -116,16 +112,13 @@ unknown_field:
             break;
         }
         s_offset += result;
-		if (itr->_field_traits.has(FieldTrait::present))
-		{
+        if (itr->_field_traits.has(FieldTrait::present)) {
             if (!itr->_field_traits.has(FieldTrait::automatic))
                 throw DuplicateField(tv);
-		}
-		else for(unsigned ii(0); ii < 2; ++ii)
-		{
+        } else
+            for (unsigned ii(0); ii < 2; ++ii) {
                 const BaseEntry *be(_ctx.find_be(tv));
-			if (!be)
-				throw UnknownField(tv);
+                if (!be) throw UnknownField(tv);
                 BaseField *bf(be->_create._do(val, be->_rlm, -1));
                 add_field_decoder(tv, ++pos, bf);
                 itr->_field_traits.set(FieldTrait::present);
@@ -133,13 +126,15 @@ unknown_field:
                 if (itr->_field_traits.has(FieldTrait::group) && has_group_count(bf))
                     s_offset = decode_group(nullptr, tv, from, s_offset, ignore);
 
-			if (itr->_ftype != FieldTrait::ft_Length || tv == Common_BodyLength) // this type expects next field to be data
+                if (itr->_ftype != FieldTrait::ft_Length ||
+                    tv == Common_BodyLength)  // this type expects next field to be data
                     break;
 
                 const unsigned val_sz(fast_atoi<unsigned>(val));
                 if (val_sz > FIX8_MAX_FLD_LENGTH - 1)
                     throw f8Exception("Value size too large");
-			result = extract_element_fixed_width(dptr + s_offset, fsize - s_offset, val_sz, tag, val);
+                result = extract_element_fixed_width(dptr + s_offset, fsize - s_offset,
+                                                     val_sz, tag, val);
                 if (!result)
                     throw MissingMandatoryField("Unable to extract fixed width field");
 
@@ -147,28 +142,31 @@ unknown_field:
                 tv = fast_atoi<unsigned short>(tag);
                 if ((itr = _fp.get_presence().find(tv)) == _fp.get_presence().end())
                     goto unknown_field;
-			if (itr->_ftype != FieldTrait::ft_data || lasttv + 1 != tv) // next field must be data, tag must be 1 greater than length tag
+                if (itr->_ftype != FieldTrait::ft_data ||
+                    lasttv + 1 != tv)  // next field must be data, tag must be 1 greater
+                                       // than length tag
                     break;
                 s_offset += result;
             }
     }
 
     const unsigned short missing(_fp.find_missing());
-	if (missing)
-	{
+    if (missing) {
         const BaseEntry *tbe(_ctx.find_be(missing));
         ostringstream ostr;
         ostr << tbe->_name << " (" << missing << ')';
         throw MissingMandatoryField(ostr.str());
     }
 
-	return permissive_mode && last_valid_pos == pos ? static_cast<unsigned>(last_valid_offset) : s_offset;
+    return permissive_mode && last_valid_pos == pos
+               ? static_cast<unsigned>(last_valid_offset)
+               : s_offset;
 }
 
 //-------------------------------------------------------------------------------------------------
-unsigned MessageBase::decode_group(GroupBase *grpbase, const unsigned short fnum, const f8String& from,
-	unsigned s_offset, unsigned ignore)
-{
+unsigned MessageBase::decode_group(GroupBase *grpbase, const unsigned short fnum,
+                                   const f8String &from, unsigned s_offset,
+                                   unsigned ignore) {
     unsigned result;
     if (!(grpbase = find_add_group(fnum, grpbase)))
         throw InvalidRepeatingGroup(fnum, FILE_LINE);
@@ -176,20 +174,23 @@ unsigned MessageBase::decode_group(GroupBase *grpbase, const unsigned short fnum
     const char *dptr(from.data());
     char tag[FIX8_MAX_FLD_LENGTH], val[FIX8_MAX_FLD_LENGTH];
 
-	for (bool ok(true); ok && s_offset < fsize; )
-	{
+    for (bool ok(true); ok && s_offset < fsize;) {
         unique_ptr<MessageBase> grp(grpbase->create_group(false));  // shallow create
 
-		for (unsigned pos(0); s_offset < fsize && (result = extract_element(dptr + s_offset, fsize - s_offset, tag, val));)
-		{
+        for (unsigned pos(0);
+             s_offset < fsize &&
+             (result = extract_element(dptr + s_offset, fsize - s_offset, tag, val));) {
             const unsigned tv(fast_atoi<unsigned>(tag));
             Presence::const_iterator itr(grp->_fp.get_presence().end());
-			if (grp->_fp.get(tv, itr, FieldTrait::present))	// already present; next group?
+            if (grp->_fp.get(tv, itr,
+                             FieldTrait::present))  // already present; next group?
                 break;
-			if (pos == 0 && grp->_fp.getPos(tv, itr) != 1)	// first field in group is mandatory
+            if (pos == 0 &&
+                grp->_fp.getPos(tv, itr) != 1)  // first field in group is mandatory
                 throw MissingRepeatingGroupField(tv);
             const BaseEntry *be(_ctx.find_be(tv));
-			if (!be || !grp->_fp.has(tv, itr))	// unknown field or field not found in sub-group - end of repeats?
+            if (!be || !grp->_fp.has(tv, itr))  // unknown field or field not found in
+                                                // sub-group - end of repeats?
             {
                 ok = false;
                 break;
@@ -204,8 +205,7 @@ unsigned MessageBase::decode_group(GroupBase *grpbase, const unsigned short fnum
         }
 
         const unsigned short missing(grp->_fp.find_missing());
-		if (missing)
-		{
+        if (missing) {
             const BaseEntry *tbe(_ctx.find_be(missing));
             ostringstream ostr;
             ostr << tbe->_name << " (" << missing << ')';
@@ -218,32 +218,30 @@ unsigned MessageBase::decode_group(GroupBase *grpbase, const unsigned short fnum
 }
 
 //-------------------------------------------------------------------------------------------------
-unsigned MessageBase::check_positions()
-{
+unsigned MessageBase::check_positions() {
     return 0;  // TODO
 }
 
 //-------------------------------------------------------------------------------------------------
-Message *Message::factory(const F8MetaCntx& ctx, const f8String& from, bool no_chksum, bool permissive_mode)
-{
+Message *Message::factory(const F8MetaCntx &ctx, const f8String &from, bool no_chksum,
+                          bool permissive_mode) {
     char mtype[MAX_MSGTYPE_FIELD_LEN]{}, len[MAX_MSGTYPE_FIELD_LEN]{};
     const unsigned hlen(extract_header(from, len, mtype));
 
-	if (!hlen)
-	{
+    if (!hlen) {
         glout_debug << "Message::factory throwing";
         throw InvalidMessage(from, FILE_LINE);
     }
 
     const unsigned mlen(fast_atoi<unsigned>(len));
     const BaseMsgEntry *bme(ctx._bme.find_ptr(mtype));
-	if (!bme)
-		throw InvalidMessage(mtype, FILE_LINE);
+    if (!bme) throw InvalidMessage(mtype, FILE_LINE);
     Message *msg(bme->_create._do(false));  // shallow create
 #if defined FIX8_CODECTIMING
     _codec_timings.start(sw_decode_time);
 #endif
-	msg->decode(from, hlen, 7, permissive_mode); // skip already decoded mandatory 8, 9, 35 and 10
+    msg->decode(from, hlen, 7,
+                permissive_mode);  // skip already decoded mandatory 8, 9, 35 and 10
 #if defined FIX8_CODECTIMING
     _codec_timings.stop(sw_decode_time);
 #endif
@@ -254,39 +252,36 @@ Message *Message::factory(const F8MetaCntx& ctx, const f8String& from, bool no_c
     msg->check_set_rlm(fitr->second);
 #endif
 
-	const char *pp(from.data() + from.size() - 7);	 // FIXME: assumes supplied string is one complete message only
+    const char *pp(from.data() + from.size() -
+                   7);  // FIXME: assumes supplied string is one complete message only
     if (*pp != '1' || *(pp + 1) != '0')  // 10=XXX^A
         throw InvalidMessage(from, FILE_LINE);
     if (!no_chksum)  // permit chksum calculation to be skipped
     {
         const f8String chksum(pp + 3, 3);
         msg->_trailer->get_check_sum()->set(chksum);
-		const unsigned chkval(fast_atoi<unsigned>(chksum.c_str())), mchkval(calc_chksum(from, 0, static_cast<unsigned>(from.size()) - 7));
-		if (chkval != mchkval)
-			throw BadCheckSum(mchkval);
+        const unsigned chkval(fast_atoi<unsigned>(chksum.c_str())),
+            mchkval(calc_chksum(from, 0, static_cast<unsigned>(from.size()) - 7));
+        if (chkval != mchkval) throw BadCheckSum(mchkval);
     }
 
     return msg;
 }
 
 //-------------------------------------------------------------------------------------------------
-// copy all fields from this message to 'to' where the field is legal for 'to' and it is not
-// already present in 'to'; includes repeating groups;
-// a deep constructed target message is required
-// if force, copy all fields regardless, replacing any existing, adding any new
-unsigned MessageBase::copy_legal(MessageBase *to, bool force) const
-{
+// copy all fields from this message to 'to' where the field is legal for 'to' and it is
+// not already present in 'to'; includes repeating groups; a deep constructed target
+// message is required if force, copy all fields regardless, replacing any existing,
+// adding any new
+unsigned MessageBase::copy_legal(MessageBase *to, bool force) const {
     unsigned copied{};
-	for (const auto& pp : _fp.get_presence())
-	{
-		if (pp._field_traits & FieldTrait::present && (force || (to->_fp.has(pp._fnum) && !to->_fp.get(pp._fnum))))
-		{
+    for (const auto &pp : _fp.get_presence()) {
+        if (pp._field_traits & FieldTrait::present &&
+            (force || (to->_fp.has(pp._fnum) && !to->_fp.get(pp._fnum)))) {
             GroupBase *gb;
-			if (pp._field_traits & FieldTrait::group && (gb = find_group(pp._fnum)))
-			{
+            if (pp._field_traits & FieldTrait::group && (gb = find_group(pp._fnum))) {
                 GroupBase *gb1(to->find_group(pp._fnum));
-				for (const auto *qq : gb->_msgs)
-				{
+                for (const auto *qq : gb->_msgs) {
                     MessageBase *grc(gb1->create_group(true));
                     copied += qq->copy_legal(grc, force);
                     *gb1 += grc;
@@ -310,19 +305,15 @@ unsigned MessageBase::copy_legal(MessageBase *to, bool force) const
 }
 
 //-------------------------------------------------------------------------------------------------
-// move all fields from this message to 'to' where the field is legal for 'to' and it is not
-// already present in 'to'; includes repeating groups;
-// if force, move all fields regardless, replacing any existing
-// not thread safe
-unsigned MessageBase::move_legal(MessageBase *to, bool force)
-{
+// move all fields from this message to 'to' where the field is legal for 'to' and it is
+// not already present in 'to'; includes repeating groups; if force, move all fields
+// regardless, replacing any existing not thread safe
+unsigned MessageBase::move_legal(MessageBase *to, bool force) {
     unsigned moved{};
-	for (const auto& pp : _fp.get_presence())
-	{
-		if (pp._field_traits & FieldTrait::present && (force || (to->_fp.has(pp._fnum) && !to->_fp.get(pp._fnum))))
-		{
-			if (pp._field_traits & FieldTrait::group)
-			{
+    for (const auto &pp : _fp.get_presence()) {
+        if (pp._field_traits & FieldTrait::present &&
+            (force || (to->_fp.has(pp._fnum) && !to->_fp.get(pp._fnum)))) {
+            if (pp._field_traits & FieldTrait::group) {
                 auto gitr(_groups.find(pp._fnum));
                 GroupBase *gb1(to->find_group(pp._fnum));
                 if (gb1)
@@ -348,140 +339,129 @@ unsigned MessageBase::move_legal(MessageBase *to, bool force)
 }
 
 //-------------------------------------------------------------------------------------------------
-size_t MessageBase::encode(char *to) const
-{
+size_t MessageBase::encode(char *to) const {
     const char *where(to);
-	for (const auto& pp : _pos)
-	{
+    for (const auto &pp : _pos) {
 #if defined FIX8_POPULATE_METADATA
         check_set_rlm(pp.second);
 #endif
         Presence::const_iterator fpitr(_fp.get_presence().end());
-		if (!_fp.get(pp.second->_fnum, fpitr, FieldTrait::suppress))	// some fields are not encoded until unsuppressed (eg. checksum)
+        if (!_fp.get(pp.second->_fnum, fpitr,
+                     FieldTrait::suppress))  // some fields are not encoded until
+                                             // unsuppressed (eg. checksum)
         {
             to += pp.second->encode(to);
-			if (fpitr->_field_traits.has(FieldTrait::group) && has_group_count(pp.second))
+            if (fpitr->_field_traits.has(FieldTrait::group) &&
+                has_group_count(pp.second))
                 to += encode_group(pp.second->_fnum, to);
         }
     }
 
-	if (_unknown.size())
-		to += _unknown.copy(to, _unknown.size());
+    if (_unknown.size()) to += _unknown.copy(to, _unknown.size());
 
     return to - where;
 }
 
 //-------------------------------------------------------------------------------------------------
-size_t MessageBase::encode(ostream& to) const
-{
+size_t MessageBase::encode(ostream &to) const {
     const std::ios::pos_type where(to.tellp());
-	for (const auto& pp : _pos)
-	{
+    for (const auto &pp : _pos) {
 #if defined FIX8_POPULATE_METADATA
         check_set_rlm(pp.second);
 #endif
         Presence::const_iterator fpitr(_fp.get_presence().end());
-		if (!_fp.get(pp.second->_fnum, fpitr, FieldTrait::suppress))	// some fields are not encoded until unsuppressed (eg. checksum)
+        if (!_fp.get(pp.second->_fnum, fpitr,
+                     FieldTrait::suppress))  // some fields are not encoded until
+                                             // unsuppressed (eg. checksum)
         {
             pp.second->encode(to);
-			if (fpitr->_field_traits.has(FieldTrait::group) && has_group_count(pp.second))
+            if (fpitr->_field_traits.has(FieldTrait::group) &&
+                has_group_count(pp.second))
                 encode_group(pp.second->_fnum, to);
         }
     }
 
-	if (_unknown.size())
-		to << _unknown;
+    if (_unknown.size()) to << _unknown;
 
     return to.tellp() - where;
 }
 
 //-------------------------------------------------------------------------------------------------
-size_t MessageBase::encode_group(const unsigned short fnum, char *to) const
-{
+size_t MessageBase::encode_group(const unsigned short fnum, char *to) const {
     const char *where(to);
     GroupBase *grpbase(find_group(fnum));
-	if (!grpbase)
-		throw InvalidRepeatingGroup(fnum, FILE_LINE);
-	for (const auto *pp : grpbase->_msgs)
-		to += pp->encode(to);
+    if (!grpbase) throw InvalidRepeatingGroup(fnum, FILE_LINE);
+    for (const auto *pp : grpbase->_msgs) to += pp->encode(to);
     return to - where;
 }
 
 //-------------------------------------------------------------------------------------------------
-size_t MessageBase::encode_group(const unsigned short fnum, std::ostream& to) const
-{
+size_t MessageBase::encode_group(const unsigned short fnum, std::ostream &to) const {
     const std::ios::pos_type where(to.tellp());
     GroupBase *grpbase(find_group(fnum));
-	if (!grpbase)
-		throw InvalidRepeatingGroup(fnum, FILE_LINE);
-	for (const auto *pp : grpbase->_msgs)
-		pp->encode(to);
+    if (!grpbase) throw InvalidRepeatingGroup(fnum, FILE_LINE);
+    for (const auto *pp : grpbase->_msgs) pp->encode(to);
     return to.tellp() - where;
 }
 
 //-------------------------------------------------------------------------------------------------
 /// Encode message with minimal copying
-size_t Message::encode(char **hmsg_store) const
-{
+size_t Message::encode(char **hmsg_store) const {
     char *moffs(*hmsg_store + HEADER_CALC_OFFSET), *msg(moffs);
 
 #if defined FIX8_CODECTIMING
     _codec_timings.start(sw_encode_time);
 #endif
 
-	if (!_header)
-		throw MissingMessageComponent("header");
+    if (!_header) throw MissingMessageComponent("header");
     _header->get_msg_type()->set(_msgType);
 
 #if defined FIX8_RAW_MSG_SUPPORT
     msg += (_begin_payload = _header->encode(msg));  // start
 #if defined FIX8_PREENCODE_MSG_SUPPORT
-	if (_preencode_len)
-	{
+    if (_preencode_len) {
         ::memcpy(msg, _preencode.data(), _payload_len = _preencode_len);
         msg += _preencode_len;
-	}
-	else
+    } else
 #endif
         msg += (_payload_len = MessageBase::encode(msg));
 #else
     msg += _header->encode(msg);  // start
 #if defined FIX8_PREENCODE_MSG_SUPPORT
-	if (_preencode_len)
-	{
+    if (_preencode_len) {
         ::memcpy(msg, _preencode.data(), _preencode_len);
         msg += _preencode_len;
-	}
-	else
+    } else
 #endif
         msg += MessageBase::encode(msg);
 #endif
 
-	if (!_trailer)
-		throw MissingMessageComponent("trailer");
+    if (!_trailer) throw MissingMessageComponent("trailer");
     msg += _trailer->encode(msg);
     const size_t msgLen(msg - moffs);  // checksummable msglength
-	const size_t hlen(_ctx._preamble_sz +
-		(msgLen < 10 ? 1 : msgLen < 100 ? 2 : msgLen < 1000 ? 3 : msgLen < 10000 ? 4 :
-		 msgLen < 100000 ? 5 : msgLen < 1000000 ? 6 : 7));
+    const size_t hlen(_ctx._preamble_sz + (msgLen < 10        ? 1
+                                           : msgLen < 100     ? 2
+                                           : msgLen < 1000    ? 3
+                                           : msgLen < 10000   ? 4
+                                           : msgLen < 100000  ? 5
+                                           : msgLen < 1000000 ? 6
+                                                              : 7));
     char *hmsg(moffs - hlen);
     *hmsg_store = hmsg;
 
-	if (!_header->get_begin_string())
-		throw MissingMandatoryField(Common_BeginString);
+    if (!_header->get_begin_string()) throw MissingMandatoryField(Common_BeginString);
     _header->_fp.clear(Common_BeginString, FieldTrait::suppress);
     hmsg += _header->get_begin_string()->encode(hmsg);
 
-	if (!_header->get_body_length())
-		throw MissingMandatoryField(Common_BodyLength);
+    if (!_header->get_body_length()) throw MissingMandatoryField(Common_BodyLength);
     _header->_fp.clear(Common_BodyLength, FieldTrait::suppress);
 
     _header->get_body_length()->set(static_cast<int>(msgLen));
     hmsg += _header->get_body_length()->encode(hmsg);
 
-	if (!_trailer->get_check_sum())
-		throw MissingMandatoryField(Common_CheckSum);
-	_trailer->get_check_sum()->set(fmt_chksum(calc_chksum(moffs - hlen, msgLen + hlen)));
+    if (!_trailer->get_check_sum()) throw MissingMandatoryField(Common_CheckSum);
+    _trailer->get_check_sum()->set(
+        fmt_chksum(calc_chksum(moffs - hlen, msgLen + hlen)));
     _trailer->_fp.clear(Common_CheckSum, FieldTrait::suppress);
     msg += _trailer->get_check_sum()->encode(msg);
 
@@ -498,8 +478,7 @@ size_t Message::encode(char **hmsg_store) const
 }
 
 //-------------------------------------------------------------------------------------------------
-size_t Message::encode(f8String& to) const
-{
+size_t Message::encode(f8String &to) const {
     char output[FIX8_MAX_MSG_LENGTH + HEADER_CALC_OFFSET], *ptr(output);
     const size_t msgLen(encode(&ptr));
     to.assign(ptr, msgLen);
@@ -507,25 +486,23 @@ size_t Message::encode(f8String& to) const
 }
 
 //-------------------------------------------------------------------------------------------------
-void MessageBase::print(ostream& os, int depth) const
-{
+void MessageBase::print(ostream &os, int depth) const {
     const string dspacer((depth + 1) * _tabsize, ' ');
     const BaseMsgEntry *tbme(_ctx._bme.find_ptr(_msgType.c_str()));
     if (tbme)
-      os << string(depth * _tabsize, ' ') << tbme->_name << " (\"" << _msgType << "\")" << endl;
-	for (const auto& pp : _pos)
-	{
+        os << string(depth * _tabsize, ' ') << tbme->_name << " (\"" << _msgType
+           << "\")" << endl;
+    for (const auto &pp : _pos) {
         const BaseEntry *tbe(_ctx.find_be(pp.second->_fnum));
-		if (!tbe)
-			throw InvalidField(pp.second->_fnum);
+        if (!tbe) throw InvalidField(pp.second->_fnum);
         os << dspacer << tbe->_name;
         const unsigned short comp(_fp.getComp(pp.second->_fnum));
-		if (comp)
-			os << " [" << _ctx._cn[comp] << ']';
+        if (comp) os << " [" << _ctx._cn[comp] << ']';
         os << " (" << pp.second->_fnum << "): ";
         int idx;
         if (pp.second->_rlm && (idx = (pp.second->get_rlm_idx())) >= 0)
-			os << pp.second->_rlm->_descriptions[idx] << " (" << *pp.second << ')' << endl;
+            os << pp.second->_rlm->_descriptions[idx] << " (" << *pp.second << ')'
+               << endl;
         else
             os << *pp.second << endl;
         if (_fp.is_group(pp.second->_fnum) && has_group_count(pp.second))
@@ -534,36 +511,32 @@ void MessageBase::print(ostream& os, int depth) const
 }
 
 //-------------------------------------------------------------------------------------------------
-void MessageBase::print_group(const unsigned short fnum, ostream& os, int depth) const
-{
+void MessageBase::print_group(const unsigned short fnum, ostream &os, int depth) const {
     const GroupBase *grpbase(find_group(fnum));
-	if (!grpbase)
-		throw InvalidRepeatingGroup(fnum, FILE_LINE);
+    if (!grpbase) throw InvalidRepeatingGroup(fnum, FILE_LINE);
 
     ++depth;
     const string dspacer(depth * _tabsize, ' ');
     size_t cnt(1);
-	for (const auto *pp : grpbase->_msgs)
-	{
-		os << dspacer << pp->_msgType << " (Repeating group " << cnt << '/' << grpbase->_msgs.size() << ')' << endl;
+    for (const auto *pp : grpbase->_msgs) {
+        os << dspacer << pp->_msgType << " (Repeating group " << cnt << '/'
+           << grpbase->_msgs.size() << ')' << endl;
         pp->print(os, depth);
         ++cnt;
     }
 }
 
 //-------------------------------------------------------------------------------------------------
-void MessageBase::print_field(const unsigned short fnum, ostream& os) const
-{
+void MessageBase::print_field(const unsigned short fnum, ostream &os) const {
     Fields::const_iterator fitr(_fields.find(fnum));
-	if (fitr != _fields.end())
-	{
+    if (fitr != _fields.end()) {
         const BaseEntry *tbe(_ctx.find_be(fnum));
-		if (!tbe)
-			throw InvalidField(fnum);
+        if (!tbe) throw InvalidField(fnum);
         os << tbe->_name << " (" << fnum << "): ";
         int idx;
         if (fitr->second->_rlm && (idx = (fitr->second->get_rlm_idx())) >= 0)
-			os << fitr->second->_rlm->_descriptions[idx] << " (" << *fitr->second << ')';
+            os << fitr->second->_rlm->_descriptions[idx] << " (" << *fitr->second
+               << ')';
         else
             os << *fitr->second;
         if (_fp.is_group(fnum) && has_group_count(fitr->second))
@@ -572,18 +545,14 @@ void MessageBase::print_field(const unsigned short fnum, ostream& os) const
 }
 
 //-------------------------------------------------------------------------------------------------
-BaseField *MessageBase::replace(const unsigned short fnum, BaseField *with)
-{
+BaseField *MessageBase::replace(const unsigned short fnum, BaseField *with) {
     BaseField *old(nullptr);
     Fields::iterator itr(_fields.find(fnum));
-	if (itr != _fields.end())
-	{
+    if (itr != _fields.end()) {
         old = itr->second;
         unsigned pos(_fp.getPos(fnum));
-		for (Positions::iterator pitr(_pos.begin()); pitr != _pos.end(); ++pitr)
-		{
-			if (pitr->second == old)
-			{
+        for (Positions::iterator pitr(_pos.begin()); pitr != _pos.end(); ++pitr) {
+            if (pitr->second == old) {
                 pos = pitr->first;
                 _pos.erase(pitr);
                 break;
@@ -597,18 +566,15 @@ BaseField *MessageBase::replace(const unsigned short fnum, BaseField *with)
 }
 
 //-------------------------------------------------------------------------------------------------
-BaseField *MessageBase::replace(const unsigned short fnum, Presence::const_iterator fitr, BaseField *with)
-{
+BaseField *MessageBase::replace(const unsigned short fnum,
+                                Presence::const_iterator fitr, BaseField *with) {
     BaseField *old(nullptr);
     Fields::iterator itr(_fields.find(fnum));
-	if (itr != _fields.end())
-	{
+    if (itr != _fields.end()) {
         old = itr->second;
         unsigned pos(_fp.getPos(fnum, fitr));
-		for (Positions::iterator pitr(_pos.begin()); pitr != _pos.end(); ++pitr)
-		{
-			if (pitr->second == old)
-			{
+        for (Positions::iterator pitr(_pos.begin()); pitr != _pos.end(); ++pitr) {
+            if (pitr->second == old) {
                 pos = pitr->first;
                 _pos.erase(pitr);
                 break;
@@ -622,17 +588,13 @@ BaseField *MessageBase::replace(const unsigned short fnum, Presence::const_itera
 }
 
 //-------------------------------------------------------------------------------------------------
-BaseField *MessageBase::remove(const unsigned short fnum)
-{
+BaseField *MessageBase::remove(const unsigned short fnum) {
     BaseField *old(nullptr);
     Fields::iterator itr(_fields.find(fnum));
-	if (itr != _fields.end())
-	{
+    if (itr != _fields.end()) {
         old = itr->second;
-		for (Positions::iterator pitr(_pos.begin()); pitr != _pos.end(); ++pitr)
-		{
-			if (pitr->second == old)
-			{
+        for (Positions::iterator pitr(_pos.begin()); pitr != _pos.end(); ++pitr) {
+            if (pitr->second == old) {
                 _pos.erase(pitr);
                 break;
             }
@@ -644,17 +606,14 @@ BaseField *MessageBase::remove(const unsigned short fnum)
 }
 
 //-------------------------------------------------------------------------------------------------
-BaseField *MessageBase::remove(const unsigned short fnum, Presence::const_iterator fitr)
-{
+BaseField *MessageBase::remove(const unsigned short fnum,
+                               Presence::const_iterator fitr) {
     BaseField *old(nullptr);
     Fields::iterator itr(_fields.find(fnum));
-	if (itr != _fields.end())
-	{
+    if (itr != _fields.end()) {
         old = itr->second;
-		for (Positions::iterator pitr(_pos.begin()); pitr != _pos.end(); ++pitr)
-		{
-			if (pitr->second == old)
-			{
+        for (Positions::iterator pitr(_pos.begin()); pitr != _pos.end(); ++pitr) {
+            if (pitr->second == old) {
                 _pos.erase(pitr);
                 break;
             }
@@ -666,8 +625,7 @@ BaseField *MessageBase::remove(const unsigned short fnum, Presence::const_iterat
 }
 
 //-------------------------------------------------------------------------------------------------
-Message *Message::clone() const
-{
+Message *Message::clone() const {
     const BaseMsgEntry &bme(_ctx._bme.find_ref(_msgType.c_str()));
     Message *msg(bme._create._do(true));
     // important not to pass force as true with copy_legal here
@@ -678,8 +636,7 @@ Message *Message::clone() const
 }
 
 //-------------------------------------------------------------------------------------------------
-void Message::print(ostream& os, int) const
-{
+void Message::print(ostream &os, int) const {
     if (_header)
         os << *_header;
     else
@@ -693,18 +650,16 @@ void Message::print(ostream& os, int) const
 
 //-------------------------------------------------------------------------------------------------
 #if defined FIX8_CODECTIMING
-void Message::format_codec_timings(const f8String& str, ostream& os, const stop_watch::value& ct)
-{
+void Message::format_codec_timings(const f8String &str, ostream &os,
+                                   const stop_watch::value &ct) {
     double avg = 1.0 * ct[stop_watch::value::_total] / ct[stop_watch::value::_count];
     os << str << ": " << setprecision(9) << ct[stop_watch::value::_total] << " usecs, "
-		<< setw(8) << right << ct[stop_watch::value::_count] << " msgs, "
-		<< avg << " usecs/msg, "
-		<< setprecision(2) << (1.0/avg) << " msgs/usec, metric="
-		<< ct;
+       << setw(8) << right << ct[stop_watch::value::_count] << " msgs, " << avg
+       << " usecs/msg, " << setprecision(2) << (1.0 / avg)
+       << " msgs/usec, metric=" << ct;
 }
 
-void Message::report_codec_timings(const f8String& tag)
-{
+void Message::report_codec_timings(const f8String &tag) {
     ostringstream ostr;
     ostr.setf(std::ios::showpoint);
     ostr.setf(std::ios::fixed);
@@ -721,15 +676,12 @@ void Message::report_codec_timings(const f8String& tag)
 #endif
 
 //-------------------------------------------------------------------------------------------------
-GroupBase *MessageBase::replace(const unsigned short fnum, GroupBase *with)
-{
+GroupBase *MessageBase::replace(const unsigned short fnum, GroupBase *with) {
     GroupBase *old(nullptr);
     auto itr(_groups.find(fnum));
-	if (itr != _groups.end())
-	{
+    if (itr != _groups.end()) {
         old = itr->second;
         itr->second = with;
     }
     return old;
 }
-
diff --git a/runtime/session.cpp b/runtime/session.cpp
index abdbdf5..779f1d6 100644
--- a/runtime/session.cpp
+++ b/runtime/session.cpp
@@ -6,49 +6,52 @@ Fix8 is released under the GNU LESSER GENERAL PUBLIC LICENSE Version 3.
 Fix8 Open Source FIX Engine.
 Copyright (C) 2010-23 David L. Dight <fix@fix8.org>
 
-Fix8 is free software: you can  redistribute it and / or modify  it under the  terms of the
-GNU Lesser General  Public License as  published  by the Free  Software Foundation,  either
-version 3 of the License, or (at your option) any later version.
-
-Fix8 is distributed in the hope  that it will be useful, but WITHOUT ANY WARRANTY;  without
-even the  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-
-You should  have received a copy of the GNU Lesser General Public  License along with Fix8.
-If not, see <http://www.gnu.org/licenses/>.
-
-BECAUSE THE PROGRAM IS  LICENSED FREE OF  CHARGE, THERE IS NO  WARRANTY FOR THE PROGRAM, TO
-THE EXTENT  PERMITTED  BY  APPLICABLE  LAW.  EXCEPT WHEN  OTHERWISE  STATED IN  WRITING THE
-COPYRIGHT HOLDERS AND/OR OTHER PARTIES  PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY
-KIND,  EITHER EXPRESSED   OR   IMPLIED,  INCLUDING,  BUT   NOT  LIMITED   TO,  THE  IMPLIED
-WARRANTIES  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO
-THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE,
-YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-IN NO EVENT UNLESS REQUIRED  BY APPLICABLE LAW  OR AGREED TO IN  WRITING WILL ANY COPYRIGHT
-HOLDER, OR  ANY OTHER PARTY  WHO MAY MODIFY  AND/OR REDISTRIBUTE  THE PROGRAM AS  PERMITTED
-ABOVE,  BE  LIABLE  TO  YOU  FOR  DAMAGES,  INCLUDING  ANY  GENERAL, SPECIAL, INCIDENTAL OR
-CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT
-NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR
-THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH
-HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+Fix8 is free software: you can  redistribute it and / or modify  it under the  terms of
+the GNU Lesser General  Public License as  published  by the Free  Software Foundation,
+either version 3 of the License, or (at your option) any later version.
+
+Fix8 is distributed in the hope  that it will be useful, but WITHOUT ANY WARRANTY;
+without even the  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+PURPOSE.
+
+You should  have received a copy of the GNU Lesser General Public  License along with
+Fix8. If not, see <http://www.gnu.org/licenses/>.
+
+BECAUSE THE PROGRAM IS  LICENSED FREE OF  CHARGE, THERE IS NO  WARRANTY FOR THE PROGRAM,
+TO THE EXTENT  PERMITTED  BY  APPLICABLE  LAW.  EXCEPT WHEN  OTHERWISE  STATED IN
+WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES  PROVIDE THE PROGRAM "AS IS" WITHOUT
+WARRANTY OF ANY KIND,  EITHER EXPRESSED   OR   IMPLIED,  INCLUDING,  BUT   NOT  LIMITED
+TO,  THE  IMPLIED WARRANTIES  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
+CORRECTION.
+
+IN NO EVENT UNLESS REQUIRED  BY APPLICABLE LAW  OR AGREED TO IN  WRITING WILL ANY
+COPYRIGHT HOLDER, OR  ANY OTHER PARTY  WHO MAY MODIFY  AND/OR REDISTRIBUTE  THE PROGRAM
+AS  PERMITTED ABOVE,  BE  LIABLE  TO  YOU  FOR  DAMAGES,  INCLUDING  ANY  GENERAL,
+SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
+THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE
+OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH
+ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
 
 */
 //-----------------------------------------------------------------------------------------
-#include "precomp.hpp"
 #include <fix8/f8includes.hpp>
 
+#include "precomp.hpp"
+
 //-------------------------------------------------------------------------------------------------
 using namespace FIX8;
 using namespace std;
 
-
 //-------------------------------------------------------------------------------------------------
-namespace
-{
+namespace {
 const string package_version{FIX8_PACKAGE_NAME " version " FIX8_PACKAGE_VERSION};
 const string copyright_short{"Copyright (c) 2010-"};
-	const string copyright_short2 { ", David L. Dight <" FIX8_PACKAGE_BUGREPORT ">, All rights reserved. [" FIX8_PACKAGE_URL "]"};
-}
+const string copyright_short2{", David L. Dight <" FIX8_PACKAGE_BUGREPORT
+                              ">, All rights reserved. [" FIX8_PACKAGE_URL "]"};
+}  // namespace
 
 //-------------------------------------------------------------------------------------------------
 RegExp SessionID::_sid("([^:]+):([^-]+)->(.+)");
@@ -57,38 +60,41 @@ RegExp SessionID::_sid("([^:]+):([^-]+)->(.+)");
 #if defined(_MSC_VER) && !defined(BUILD_F8API)
 // no need in definition since it is in dll already
 #else
-const vector<f8String> Session::_state_names
-{
-	"none", "continuous", "session_terminated",
-	"wait_for_logon", "not_logged_in", "logon_sent", "logon_received", "logoff_sent",
-	"logoff_received", "test_request_sent", "sequence_reset_sent",
-	"sequence_reset_received", "resend_request_sent", "resend_request_received"
-};
+const vector<f8String> Session::_state_names{"none",
+                                             "continuous",
+                                             "session_terminated",
+                                             "wait_for_logon",
+                                             "not_logged_in",
+                                             "logon_sent",
+                                             "logon_received",
+                                             "logoff_sent",
+                                             "logoff_received",
+                                             "test_request_sent",
+                                             "sequence_reset_sent",
+                                             "sequence_reset_received",
+                                             "resend_request_sent",
+                                             "resend_request_received"};
 #endif
 #if defined(_MSC_VER)
 #pragma warning(push)
 #pragma warning(disable : 4273)
 #endif
 //-------------------------------------------------------------------------------------------------
-void SessionID::make_id()
-{
+void SessionID::make_id() {
     ostringstream ostr;
     ostr << _beginString << ':' << _senderCompID << "->" << _targetCompID;
     _id = ostr.str();
 }
 
 //-------------------------------------------------------------------------------------------------
-SessionID SessionID::make_reverse_id() const
-{
+SessionID SessionID::make_reverse_id() const {
     return SessionID(_beginString(), _targetCompID(), _senderCompID());
 }
 
 //-------------------------------------------------------------------------------------------------
-void SessionID::from_string(const f8String& from)
-{
+void SessionID::from_string(const f8String &from) {
     RegMatch match;
-	if (_sid.SearchString(match, from, 4) == 4)
-	{
+    if (_sid.SearchString(match, from, 4) == 4) {
         f8String bstr, scid, tcid;
         _sid.SubExpr(match, from, bstr, 0, 1);
         _beginString.set(bstr);
@@ -102,77 +108,88 @@ void SessionID::from_string(const f8String& from)
 
 //-------------------------------------------------------------------------------------------------
 //-------------------------------------------------------------------------------------------------
-Session::Session(const F8MetaCntx& ctx, const SessionID& sid, Persister *persist, Logger *logger, Logger *plogger) :
-_state(States::st_none),
-_ctx(ctx), _connection(), _req_next_send_seq(), _req_next_receive_seq(),
-	_sid(sid), _sf(), _persist(persist), _logger(logger), _plogger(plogger),	// initiator
-	_timer(*this, 10), _hb_processor(&Session::heartbeat_service, true),
-	_session_scheduler(&Session::activation_service, true), _schedule()
-{
+Session::Session(const F8MetaCntx &ctx, const SessionID &sid, Persister *persist,
+                 Logger *logger, Logger *plogger)
+    : _state(States::st_none),
+      _ctx(ctx),
+      _connection(),
+      _req_next_send_seq(),
+      _req_next_receive_seq(),
+      _sid(sid),
+      _sf(),
+      _persist(persist),
+      _logger(logger),
+      _plogger(plogger),  // initiator
+      _timer(*this, 10),
+      _hb_processor(&Session::heartbeat_service, true),
+      _session_scheduler(&Session::activation_service, true),
+      _schedule() {
     _timer.start();
     _batchmsgs_buffer.reserve(10 * (FIX8_MAX_MSG_LENGTH + HEADER_CALC_OFFSET));
 
-	if (!_logger)
-	{
+    if (!_logger) {
         glout_warn << "Warning: no session logger defined for " << _sid;
     }
 
-	if (!_plogger)
-	{
+    if (!_plogger) {
         glout_warn << "Warning: no protocol logger defined for " << _sid;
     }
 
-	if (!_persist)
-	{
+    if (!_persist) {
         glout_warn << "Warning: no persister defined for " << _sid;
     }
 }
 
 //-------------------------------------------------------------------------------------------------
-Session::Session(const F8MetaCntx& ctx, const sender_comp_id& sci, Persister *persist, Logger *logger, Logger *plogger) :
-_state(States::st_none),
-_ctx(ctx), _sci(sci), _connection(), _req_next_send_seq(), _req_next_receive_seq(),
-	_sf(), _persist(persist), _logger(logger), _plogger(plogger),	// acceptor
-	_timer(*this, 10), _hb_processor(&Session::heartbeat_service, true),
-	_session_scheduler(&Session::activation_service, true), _schedule()
-{
+Session::Session(const F8MetaCntx &ctx, const sender_comp_id &sci, Persister *persist,
+                 Logger *logger, Logger *plogger)
+    : _state(States::st_none),
+      _ctx(ctx),
+      _sci(sci),
+      _connection(),
+      _req_next_send_seq(),
+      _req_next_receive_seq(),
+      _sf(),
+      _persist(persist),
+      _logger(logger),
+      _plogger(plogger),  // acceptor
+      _timer(*this, 10),
+      _hb_processor(&Session::heartbeat_service, true),
+      _session_scheduler(&Session::activation_service, true),
+      _schedule() {
     _timer.start();
     _batchmsgs_buffer.reserve(10 * (FIX8_MAX_MSG_LENGTH + HEADER_CALC_OFFSET));
 }
 
 //-------------------------------------------------------------------------------------------------
-void Session::atomic_init(States::SessionStates st)
-{
+void Session::atomic_init(States::SessionStates st) {
     do_state_change(st);
     _next_send_seq = _next_receive_seq = 1;
     _active = true;
 }
 
 //-------------------------------------------------------------------------------------------------
-Session::~Session()
-{
+Session::~Session() {
     slout_info << "Session terminating";
-	if (_logger)
-		_logger->stop();
-	if (_plogger)
-		_plogger->stop();
+    if (_logger) _logger->stop();
+    if (_plogger) _plogger->stop();
     hypersleep<h_seconds>(1);  // needed for service threads to exit gracefully
 
-	if (_connection && _connection->get_role() == Connection::cn_acceptor)
-		{ f8_scoped_spin_lock guard(_per_spl); delete _persist; _persist = 0; }
+    if (_connection && _connection->get_role() == Connection::cn_acceptor) {
+        f8_scoped_spin_lock guard(_per_spl);
+        delete _persist;
+        _persist = 0;
+    }
     delete _schedule;
 }
 
 //-------------------------------------------------------------------------------------------------
 int Session::start(Connection *connection, bool wait, const unsigned send_seqnum,
-	const unsigned recv_seqnum, const f8String davi)
-{
+                   const unsigned recv_seqnum, const f8String davi) {
     glout_info << copyright_string();
-	if (_logger)
-		_logger->purge_thread_codes();
+    if (_logger) _logger->purge_thread_codes();
 
-	if (_plogger)
-		_plogger->purge_thread_codes();
+    if (_plogger) _plogger->purge_thread_codes();
 
     _control.clear(shutdown);
     slout_info << "Starting session";
@@ -180,39 +197,30 @@ int Session::start(Connection *connection, bool wait, const unsigned send_seqnum
     if (!_connection->connect())  // if already connected returns true
         return -1;
     if (_connection->get_role() == Connection::cn_acceptor)
-		atomic_init(States::st_wait_for_logon); // important for server that this is done before connect
+        atomic_init(States::st_wait_for_logon);  // important for server that this is
+                                                 // done before connect
     _connection->start();
     slout_info << "Session connected";
 
-	if (_connection->get_role() == Connection::cn_initiator)
-	{
+    if (_connection->get_role() == Connection::cn_initiator) {
         atomic_init(States::st_not_logged_in);
         if (_loginParameters._reset_sequence_numbers)
             _next_send_seq = _next_receive_seq = 1;
-		else
-		{
+        else {
             recover_seqnums();
-			if (send_seqnum)
-				_next_send_seq = send_seqnum;
-			if (recv_seqnum)
-				_next_receive_seq = recv_seqnum;
+            if (send_seqnum) _next_send_seq = send_seqnum;
+            if (recv_seqnum) _next_receive_seq = recv_seqnum;
         }
 
         send(generate_logon(_connection->get_hb_interval(), davi));
         do_state_change(States::st_logon_sent);
-	}
-	else
-	{
-		if (send_seqnum)
-			_req_next_send_seq = send_seqnum;
-		if (recv_seqnum)
-			_req_next_receive_seq = recv_seqnum;
+    } else {
+        if (send_seqnum) _req_next_send_seq = send_seqnum;
+        if (recv_seqnum) _req_next_receive_seq = recv_seqnum;
     }
 
-	if (_sf && (_schedule = _sf->create_session_schedule(_sf->_ses)))
-	{
-		if (_connection->get_role() == Connection::cn_initiator)
-		{
+    if (_sf && (_schedule = _sf->create_session_schedule(_sf->_ses))) {
+        if (_connection->get_role() == Connection::cn_initiator) {
             slout_info << *_schedule;
         }
         _timer.schedule(_session_scheduler, 1000);  // check every second
@@ -227,22 +235,16 @@ int Session::start(Connection *connection, bool wait, const unsigned send_seqnum
 }
 
 //-------------------------------------------------------------------------------------------------
-void Session::stop(const bool clearTimer)
-{
-	if (_control & shutdown)
-		return;
+void Session::stop(const bool clearTimer) {
+    if (_control & shutdown) return;
     _control |= shutdown;
 
-	if (_connection)
-	{
-        if (_connection->get_role() == Connection::cn_initiator &&
-                clearTimer)
+    if (_connection) {
+        if (_connection->get_role() == Connection::cn_initiator && clearTimer)
             _timer.clear();
-		else
-		{
+        else {
             f8_scoped_spin_lock guard(_per_spl, _connection->get_pmodel() == pm_coro);
-			if (_persist)
-				_persist->stop();
+            if (_persist) _persist->stop();
         }
         _connection->stop();
     }
@@ -250,13 +252,11 @@ void Session::stop(const bool clearTimer)
 }
 
 //-------------------------------------------------------------------------------------------------
-bool Session::enforce(const unsigned seqnum, const Message *msg)
-{
-	if (States::is_established(_state))
-	{
-		if (_state != States::st_logon_received)
-			compid_check(seqnum, msg, _sid);
-		if (msg->get_msgtype() != Common_MsgType_SEQUENCE_RESET && sequence_check(seqnum, msg))
+bool Session::enforce(const unsigned seqnum, const Message *msg) {
+    if (States::is_established(_state)) {
+        if (_state != States::st_logon_received) compid_check(seqnum, msg, _sid);
+        if (msg->get_msgtype() != Common_MsgType_SEQUENCE_RESET &&
+            sequence_check(seqnum, msg))
             return false;
     }
 
@@ -264,28 +264,25 @@ bool Session::enforce(const unsigned seqnum, const Message *msg)
 }
 
 //-------------------------------------------------------------------------------------------------
-void Session::update_persist_seqnums()
-{
-	if (_persist)
-	{
-		f8_scoped_spin_lock guard(_per_spl, _connection && _connection->get_pmodel() == pm_coro);
+void Session::update_persist_seqnums() {
+    if (_persist) {
+        f8_scoped_spin_lock guard(_per_spl,
+                                  _connection && _connection->get_pmodel() == pm_coro);
         _persist->put(_next_send_seq, _next_receive_seq);
-		//cout << "Persisted:" << _next_send_seq << " and " << _next_receive_seq << endl;
+        // cout << "Persisted:" << _next_send_seq << " and " << _next_receive_seq <<
+        // endl;
     }
 }
 
 //-------------------------------------------------------------------------------------------------
-bool Session::process(const f8String& from)
-{
+bool Session::process(const f8String &from) {
     unsigned seqnum(0);
     bool remote_logged_out{};
     const Message *msg = nullptr;
 
-	try
-	{
+    try {
         const f8String::size_type fpos(from.find("34="));
-		if (fpos == f8String::npos)
-		{
+        if (fpos == f8String::npos) {
             slout_debug << "Session::process throwing for " << from;
             throw InvalidMessage(from, FILE_LINE);
         }
@@ -293,16 +290,15 @@ bool Session::process(const f8String& from)
         seqnum = fast_atoi<unsigned>(from.data() + fpos + 3, default_field_separator);
 
         bool retry_plog(false);
-		if (_plogger && _plogger->has_flag(Logger::inbound))
-		{
+        if (_plogger && _plogger->has_flag(Logger::inbound)) {
             if (_state != States::st_wait_for_logon)
                 plog(from, Logger::Info, 1);
             else
                 retry_plog = true;
         }
 
-		if (!(msg = Message::factory(_ctx, from, _loginParameters._no_chksum_flag, _loginParameters._permissive_mode_flag)))
-		{
+        if (!(msg = Message::factory(_ctx, from, _loginParameters._no_chksum_flag,
+                                     _loginParameters._permissive_mode_flag))) {
             glout_fatal << "Fatal: factory failed to generate a valid message";
             return false;
         }
@@ -312,11 +308,12 @@ bool Session::process(const f8String& from)
         else if (_control & print)
             cout << *msg << endl;
 
-		bool result(false), admin_result(msg->is_admin() ? handle_admin(seqnum, msg) : true);
+        bool result(false),
+            admin_result(msg->is_admin() ? handle_admin(seqnum, msg) : true);
         if (msg->get_msgtype().size() > 1)
             goto application_call;
-		else switch(msg->get_msgtype()[0])
-		{
+        else
+            switch (msg->get_msgtype()[0]) {
                 default:
                 application_call:
                     if (activation_check(seqnum, msg))
@@ -347,8 +344,7 @@ application_call:
             }
 
         ++_next_receive_seq;
-		if (retry_plog)
-			plog(from, Logger::Info, 1);
+        if (retry_plog) plog(from, Logger::Info, 1);
 
         update_persist_seqnums();
 
@@ -360,35 +356,28 @@ application_call:
 
         delete msg;
         return result && admin_result;
-	}
-	catch (LogfileException& e)
-	{
+    } catch (LogfileException &e) {
         cerr << e.what() << endl;
-	}
-	catch (f8Exception& e)
-	{
+    } catch (f8Exception &e) {
         slout_debug << "process: f8exception" << ' ' << seqnum << ' ' << e.what();
 
-		if (e.force_logoff())
-		{
+        if (e.force_logoff()) {
             if (_plogger && _plogger->has_flag(Logger::inbound))
                 plog(from, Logger::Info, 1);
             slout_fatal << e.what() << " - will logoff";
-			if (_state == States::st_logon_received && !_loginParameters._silent_disconnect)
-			{
+            if (_state == States::st_logon_received &&
+                !_loginParameters._silent_disconnect) {
                 do_state_change(States::st_session_terminated);
-				send(generate_logout(e.what()), true, 0, true); // so it won't increment
+                send(generate_logout(e.what()), true, 0,
+                     true);  // so it won't increment
                 do_state_change(States::st_logoff_sent);
             }
-			if (_loginParameters._reliable)
-			{
+            if (_loginParameters._reliable) {
                 slout_debug << "rethrowing ...";
                 throw;
             }
             stop();
-		}
-		else
-		{
+        } else {
             slout_error << e.what() << " - inbound message rejected";
             handle_outbound_reject(seqnum, msg, e.what());
             ++_next_receive_seq;
@@ -397,14 +386,10 @@ application_call:
             delete msg;
             return true;  // message is handled but has errors
         }
-	}
-	catch (Poco::Net::NetException& e)
-	{
+    } catch (Poco::Net::NetException &e) {
         slout_debug << "process:: Poco::Net::NetException";
         slout_error << e.what();
-	}
-	catch (exception& e)
-	{
+    } catch (exception &e) {
         slout_debug << "process:: std::exception";
         slout_error << e.what();
     }
@@ -413,10 +398,9 @@ application_call:
 }
 
 //-------------------------------------------------------------------------------------------------
-void Session::compid_check(const unsigned seqnum, const Message *msg, const SessionID& id) const
-{
-	if (_loginParameters._enforce_compids)
-	{
+void Session::compid_check(const unsigned seqnum, const Message *msg,
+                           const SessionID &id) const {
+    if (_loginParameters._enforce_compids) {
         if (!id.same_sender_comp_id(msg->Header()->get<target_comp_id>()->get()))
             throw BadCompidId(msg->Header()->get<target_comp_id>()->get());
         if (!id.same_target_comp_id(msg->Header()->get<sender_comp_id>()->get()))
@@ -425,19 +409,16 @@ void Session::compid_check(const unsigned seqnum, const Message *msg, const Sess
 }
 
 //-------------------------------------------------------------------------------------------------
-bool Session::sequence_check(const unsigned seqnum, const Message *msg)
-{
+bool Session::sequence_check(const unsigned seqnum, const Message *msg) {
     // cout << "seqnum:" << seqnum << " next_target_seq:" << _next_receive_seq
-		//<< " next_sender_seq:" << _next_send_seq << " state:" << _state << " next_receive_seq:" <<  _next_receive_seq << endl;
+    //<< " next_sender_seq:" << _next_send_seq << " state:" << _state << "
+    // next_receive_seq:" <<  _next_receive_seq << endl;
 
-	if (seqnum > _next_receive_seq)
-	{
-		if (_state == States::st_resend_request_sent)
-		{
+    if (seqnum > _next_receive_seq) {
+        if (_state == States::st_resend_request_sent) {
             slout_warn << "Resend request already sent";
         }
-		if (_state == States::st_continuous)
-		{
+        if (_state == States::st_continuous) {
             send(generate_resend_request(_next_receive_seq));
             do_state_change(States::st_resend_request_sent);
         }
@@ -447,8 +428,7 @@ bool Session::sequence_check(const unsigned seqnum, const Message *msg)
         return false;
     }
 
-	if (seqnum < _next_receive_seq)
-	{
+    if (seqnum < _next_receive_seq) {
         poss_dup_flag pdf(false);
         msg->Header()->get(pdf);
         if (!pdf())  // poss dup not set so bad
@@ -456,8 +436,7 @@ bool Session::sequence_check(const unsigned seqnum, const Message *msg)
         sending_time st;
         msg->Header()->get(st);
         orig_sending_time ost;
-		if (msg->Header()->get(ost) && ost() > st())
-		{
+        if (msg->Header()->get(ost) && ost() > st()) {
             ostringstream ostr;
             ost.print(ostr);
             throw BadSendingTime(ostr.str());
@@ -468,28 +447,25 @@ bool Session::sequence_check(const unsigned seqnum, const Message *msg)
 }
 
 //-------------------------------------------------------------------------------------------------
-bool Session::handle_logon(const unsigned seqnum, const Message *msg)
-{
-	if (_state == States::st_continuous)
-	{
+bool Session::handle_logon(const unsigned seqnum, const Message *msg) {
+    if (_state == States::st_continuous) {
         send(generate_reject(seqnum, "Already logged on"), msg->get_msgtype().c_str());
         return true;
     }
     do_state_change(States::st_logon_received);
-	const bool reset_given(msg->have(Common_ResetSeqNumFlag) && msg->get<reset_seqnum_flag>()->get());
+    const bool reset_given(msg->have(Common_ResetSeqNumFlag) &&
+                           msg->get<reset_seqnum_flag>()->get());
     sender_comp_id sci;  // so this should be our tci
     msg->Header()->get(sci);
     target_comp_id tci;  // so this should be our sci
     msg->Header()->get(tci);
     SessionID id(_ctx._beginStr, tci(), sci());
 
-	if (_connection->get_role() == Connection::cn_initiator)
-	{
-		if (id != _sid)
-		{
-			glout_warn << "Inbound TargetCompID not recognised (" << tci << "), expecting (" << _sid.get_senderCompID() << ')';
-			if (_loginParameters._enforce_compids)
-			{
+    if (_connection->get_role() == Connection::cn_initiator) {
+        if (id != _sid) {
+            glout_warn << "Inbound TargetCompID not recognised (" << tci
+                       << "), expecting (" << _sid.get_senderCompID() << ')';
+            if (_loginParameters._enforce_compids) {
                 stop();
                 do_state_change(States::st_session_terminated);
                 return false;
@@ -498,70 +474,66 @@ bool Session::handle_logon(const unsigned seqnum, const Message *msg)
 
         enforce(seqnum, msg);
         do_state_change(States::st_continuous);
-	}
-	else // acceptor
+    } else  // acceptor
     {
         default_appl_ver_id davi;
         msg->get(davi);
 
-		if (_sci() != tci())
-		{
-			glout_warn << "Inbound TargetCompID not recognised (" << tci << "), expecting (" << _sci << ')';
-			if (_loginParameters._enforce_compids)
-			{
+        if (_sci() != tci()) {
+            glout_warn << "Inbound TargetCompID not recognised (" << tci
+                       << "), expecting (" << _sci << ')';
+            if (_loginParameters._enforce_compids) {
                 stop();
                 do_state_change(States::st_session_terminated);
                 return false;
             }
         }
 
-		if (!_loginParameters._clients.empty())
-		{
+        if (!_loginParameters._clients.empty()) {
             auto itr(_loginParameters._clients.find(sci()));
             bool iserr(false);
-			if (itr == _loginParameters._clients.cend())
-			{
-				glout_error << "Remote (" << sci << ") not found (" << id << "). NOT authorised to proceed.";
+            if (itr == _loginParameters._clients.cend()) {
+                glout_error << "Remote (" << sci << ") not found (" << id
+                            << "). NOT authorised to proceed.";
                 iserr = true;
             }
 
-			if (!iserr && get<1>(itr->second) != Poco::Net::IPAddress()
-				&& get<1>(itr->second) != _connection->get_peer_socket_address().host())
-			{
-				glout_error << "Remote (" << get<0>(itr->second) << ", " << sci << ") NOT authorised to proceed ("
-					<< _connection->get_peer_socket_address().toString() << ").";
+            if (!iserr && get<1>(itr->second) != Poco::Net::IPAddress() &&
+                get<1>(itr->second) != _connection->get_peer_socket_address().host()) {
+                glout_error << "Remote (" << get<0>(itr->second) << ", " << sci
+                            << ") NOT authorised to proceed ("
+                            << _connection->get_peer_socket_address().toString()
+                            << ").";
                 iserr = true;
             }
 
-			if (iserr)
-			{
+            if (iserr) {
                 stop();
                 do_state_change(States::st_session_terminated);
                 return false;
             }
 
-			glout_info << "Remote (" << get<0>(itr->second) << ", " << sci << ") authorised to proceed ("
+            glout_info << "Remote (" << get<0>(itr->second) << ", " << sci
+                       << ") authorised to proceed ("
                        << _connection->get_peer_socket_address().toString() << ").";
         }
 
         // important - these objects can't be created until we have a valid SessionID
-		if (_sf)
-		{
-			if (!_logger && !(_logger = _sf->create_logger(_sf->_ses, Configuration::session_log, &id)))
-			{
+        if (_sf) {
+            if (!_logger && !(_logger = _sf->create_logger(
+                                  _sf->_ses, Configuration::session_log, &id))) {
                 glout_warn << "Warning: no session logger defined for " << id;
             }
 
-			if (!_plogger && !(_plogger = _sf->create_logger(_sf->_ses, Configuration::protocol_log, &id)))
-			{
+            if (!_plogger && !(_plogger = _sf->create_logger(
+                                   _sf->_ses, Configuration::protocol_log, &id))) {
                 glout_warn << "Warning: no protocol logger defined for " << id;
             }
 
-			if (!_persist)
-			{
-				f8_scoped_spin_lock guard(_per_spl, _connection->get_pmodel() == pm_coro);
-				if (!(_persist = _sf->create_persister(_sf->_ses, &id, reset_given)))
-				{
+            if (!_persist) {
+                f8_scoped_spin_lock guard(_per_spl,
+                                          _connection->get_pmodel() == pm_coro);
+                if (!(_persist = _sf->create_persister(_sf->_ses, &id, reset_given))) {
                     glout_warn << "Warning: no persister defined for " << id;
                 }
             }
@@ -570,30 +542,24 @@ bool Session::handle_logon(const unsigned seqnum, const Message *msg)
 			if (_schedule)
 				slout_info << *_schedule;
 #endif
-		}
-		else
-		{
+        } else {
             glout_error << "Error: SessionConfig object missing in session";
         }
 
-		slout_info << "Connection from " << _connection->get_peer_socket_address().toString();
+        slout_info << "Connection from "
+                   << _connection->get_peer_socket_address().toString();
 
         if (reset_given)  // ignore version restrictions on this behaviour
         {
             slout_info << "Resetting sequence numbers";
             _next_send_seq = _next_receive_seq = 1;
-		}
-		else
-		{
+        } else {
             recover_seqnums();
-			if (_req_next_send_seq)
-				_next_send_seq = _req_next_send_seq;
-			if (_req_next_receive_seq)
-				_next_receive_seq = _req_next_receive_seq;
+            if (_req_next_send_seq) _next_send_seq = _req_next_send_seq;
+            if (_req_next_receive_seq) _next_receive_seq = _req_next_receive_seq;
         }
 
-		if (authenticate(id, msg))
-		{
+        if (authenticate(id, msg)) {
             _sid = id;
             enforce(seqnum, msg);
             heartbeat_interval hbi;
@@ -602,17 +568,15 @@ bool Session::handle_logon(const unsigned seqnum, const Message *msg)
             send(generate_logon(hbi(), davi()));
             do_state_change(States::st_continuous);
             slout_info << "Client setting heartbeat interval to " << hbi();
-		}
-		else
-		{
+        } else {
             slout_error << id << " failed authentication";
             stop();
             do_state_change(States::st_session_terminated);
             return false;
         }
 
-		if (_loginParameters._login_schedule.is_valid() && !_loginParameters._login_schedule.test())
-		{
+        if (_loginParameters._login_schedule.is_valid() &&
+            !_loginParameters._login_schedule.test()) {
             slout_error << id << " Session unavailable. Login not accepted.";
             stop();
             do_state_change(States::st_session_terminated);
@@ -628,8 +592,7 @@ bool Session::handle_logon(const unsigned seqnum, const Message *msg)
 }
 
 //-------------------------------------------------------------------------------------------------
-bool Session::handle_logout(const unsigned seqnum, const Message *msg)
-{
+bool Session::handle_logout(const unsigned seqnum, const Message *msg) {
     enforce(seqnum, msg);
 
     // if (_state != States::st_logoff_sent)
@@ -640,14 +603,14 @@ bool Session::handle_logout(const unsigned seqnum, const Message *msg)
 }
 
 //-------------------------------------------------------------------------------------------------
-bool Session::handle_sequence_reset(const unsigned seqnum, const Message *msg)
-{
+bool Session::handle_sequence_reset(const unsigned seqnum, const Message *msg) {
     enforce(seqnum, msg);
 
     new_seq_num nsn;
-	if (msg->get(nsn))
-	{
-		slout_debug << "newseqnum = " << nsn() << ", _next_receive_seq = " << _next_receive_seq << " seqnum:" << seqnum;
+    if (msg->get(nsn)) {
+        slout_debug << "newseqnum = " << nsn()
+                    << ", _next_receive_seq = " << _next_receive_seq
+                    << " seqnum:" << seqnum;
         if (nsn() >= static_cast<int>(_next_receive_seq))
             _next_receive_seq = nsn() - 1;
         else if (nsn() < static_cast<int>(_next_receive_seq))
@@ -661,43 +624,37 @@ bool Session::handle_sequence_reset(const unsigned seqnum, const Message *msg)
 }
 
 //-------------------------------------------------------------------------------------------------
-bool Session::handle_resend_request(const unsigned seqnum, const Message *msg)
-{
+bool Session::handle_resend_request(const unsigned seqnum, const Message *msg) {
     enforce(seqnum, msg);
 
-	if (_state != States::st_resend_request_received)
-	{
+    if (_state != States::st_resend_request_received) {
         begin_seq_num begin;
         end_seq_num end;
 
-		if (!msg->get(begin))
-		{
+        if (!msg->get(begin)) {
             slout_warn << "handle_resend_request: can't obtain BeginSeqNo from request";
         }
-		if (!msg->get(end))
-		{
+        if (!msg->get(end)) {
             slout_warn << "handle_resend_request: can't obtain EndSeqNo from request";
         }
 
         if ((begin() > end() && end()) || begin() == 0)
-			handle_outbound_reject(seqnum, msg, "Invalid resend range: Begin > End or Begin = 0");
-		else if (!_persist)
-		{
-			const int nxt(static_cast<int>(_next_send_seq)), nseq(begin() >= nxt ? begin() + 1 : nxt);
+            handle_outbound_reject(seqnum, msg,
+                                   "Invalid resend range: Begin > End or Begin = 0");
+        else if (!_persist) {
+            const int nxt(static_cast<int>(_next_send_seq)),
+                nseq(begin() >= nxt ? begin() + 1 : nxt);
             send(generate_sequence_reset(nseq, true), true, begin());
             _next_send_seq = nseq;
             slout_debug << "handle_resend_request scenario #" << (nseq == nxt ? 7 : 8);
-		}
-		else
-		{
+        } else {
             // cout << "got resend request:" << begin() << " to " << end() << endl;
             do_state_change(States::st_resend_request_received);
-			//f8_scoped_spin_lock guard(_per_spl, _connection->get_pmodel() == pm_coro); // no no nanette!
+            // f8_scoped_spin_lock guard(_per_spl, _connection->get_pmodel() ==
+            // pm_coro); // no no nanette!
             _persist->get(begin(), end(), *this, &Session::retrans_callback);
         }
-	}
-	else
-	{
+    } else {
         slout_warn << "resend request received during an existing resend sequence";
     }
 
@@ -705,58 +662,60 @@ bool Session::handle_resend_request(const unsigned seqnum, const Message *msg)
 }
 
 //-------------------------------------------------------------------------------------------------
-bool Session::retrans_callback(const SequencePair& with, RetransmissionContext& rctx)
-{
+bool Session::retrans_callback(const SequencePair &with, RetransmissionContext &rctx) {
     // cout << "first:" << with.first << ' ' << rctx << endl;
 
-	if (rctx._no_more_records)
-	{
+    if (rctx._no_more_records) {
         /*
         if (rctx._end)
         {
                 _next_send_seq = rctx._interrupted_seqnum - 1;
-			send(generate_sequence_reset(rctx._interrupted_seqnum, true), true, rctx._last + 1);
+                send(generate_sequence_reset(rctx._interrupted_seqnum, true), true,
+        rctx._last + 1);
                 //cout << "#1" << endl;
         }
         else if (!rctx._last)
         {
                 _next_send_seq = rctx._interrupted_seqnum;
-			send(generate_sequence_reset(rctx._interrupted_seqnum, true), true, rctx._begin);
+                send(generate_sequence_reset(rctx._interrupted_seqnum, true), true,
+        rctx._begin);
                 //cout << "#4" << endl;
         }
         */
         if (!rctx._last)  // start to infinity requested
         {
-			// handle case where requested seq is greater than current last sent seq (interrupted)
-			const unsigned nseq(rctx._begin >= rctx._interrupted_seqnum ? rctx._begin + 1 : rctx._interrupted_seqnum);
+            // handle case where requested seq is greater than current last sent seq
+            // (interrupted)
+            const unsigned nseq(rctx._begin >= rctx._interrupted_seqnum
+                                    ? rctx._begin + 1
+                                    : rctx._interrupted_seqnum);
             send(generate_sequence_reset(nseq, true), true, rctx._begin);
             _next_send_seq = nseq;
-			slout_debug << "retrans_callback scenario #" << (nseq == rctx._interrupted_seqnum ? 4 : 5) << ' ' << rctx;
-		}
-		else // range requested // was: if (rctx._end)
-		{
-			// handle case where requested seq is greater than current last sent seq (interrupted)
-			const unsigned nseq(rctx._last + 1 >= rctx._interrupted_seqnum ? rctx._last + 2 : rctx._interrupted_seqnum);
+            slout_debug << "retrans_callback scenario #"
+                        << (nseq == rctx._interrupted_seqnum ? 4 : 5) << ' ' << rctx;
+        } else  // range requested // was: if (rctx._end)
+        {
+            // handle case where requested seq is greater than current last sent seq
+            // (interrupted)
+            const unsigned nseq(rctx._last + 1 >= rctx._interrupted_seqnum
+                                    ? rctx._last + 2
+                                    : rctx._interrupted_seqnum);
             send(generate_sequence_reset(nseq, true), true, rctx._last + 1);
             _next_send_seq = nseq;
-			slout_debug << "retrans_callback scenario #" << (nseq == rctx._interrupted_seqnum ? 1 : 6) << ' ' << rctx;
+            slout_debug << "retrans_callback scenario #"
+                        << (nseq == rctx._interrupted_seqnum ? 1 : 6) << ' ' << rctx;
         }
         do_state_change(States::st_continuous);
         return true;
     }
 
-	if (rctx._last)
-	{
-		if (rctx._last + 1 < with.first)
-		{
+    if (rctx._last) {
+        if (rctx._last + 1 < with.first) {
             send(generate_sequence_reset(with.first, true), true, _next_send_seq);
             slout_debug << "retrans_callback scenario #2, " << rctx;
         }
-	}
-	else
-	{
-		if (with.first > rctx._begin)
-		{
+    } else {
+        if (with.first > rctx._begin) {
             send(generate_sequence_reset(with.first, true));
             slout_debug << "retrans_callback scenario #3, " << rctx;
         }
@@ -769,8 +728,7 @@ bool Session::retrans_callback(const SequencePair& with, RetransmissionContext&
 }
 
 //-------------------------------------------------------------------------------------------------
-bool Session::handle_test_request(const unsigned seqnum, const Message *msg)
-{
+bool Session::handle_test_request(const unsigned seqnum, const Message *msg) {
     enforce(seqnum, msg);
 
     test_request_id testReqID;
@@ -780,25 +738,25 @@ bool Session::handle_test_request(const unsigned seqnum, const Message *msg)
 }
 
 //-------------------------------------------------------------------------------------------------
-bool Session::handle_outbound_reject(const unsigned seqnum, const Message *msg, const char *errstr)
-{
-	return send(generate_reject(seqnum, errstr, msg && !msg->get_msgtype().empty() ? msg->get_msgtype().c_str() : nullptr));
+bool Session::handle_outbound_reject(const unsigned seqnum, const Message *msg,
+                                     const char *errstr) {
+    return send(generate_reject(
+        seqnum, errstr,
+        msg && !msg->get_msgtype().empty() ? msg->get_msgtype().c_str() : nullptr));
 }
 
 //-------------------------------------------------------------------------------------------------
 bool Session::activation_service()  // called on the timer threead
 {
     // cout << "activation_service()" << endl;
-	if (is_shutdown())
-		return false;
+    if (is_shutdown()) return false;
 
-	if (_connection && _connection->is_connected())
-	{
+    if (_connection && _connection->is_connected()) {
         const bool curr(_active);
         _active = _schedule->_sch.test(curr);
-		if (curr != _active)
-		{
-			slout_info << "Session activation transitioned to " << (_active ? "active" : "inactive");
+        if (curr != _active) {
+            slout_info << "Session activation transitioned to "
+                       << (_active ? "active" : "inactive");
         }
     }
 
@@ -806,52 +764,46 @@ bool Session::activation_service()	// called on the timer threead
 }
 
 //-------------------------------------------------------------------------------------------------
-bool Session::heartbeat_service()
-{
+bool Session::heartbeat_service() {
     // cout << "heartbeat_service()" << endl;
-	if (is_shutdown())
-		return false;
+    if (is_shutdown()) return false;
 
-	if (_connection && _connection->is_connected())
-	{
+    if (_connection && _connection->is_connected()) {
         Tickval now(true);
-		if ((now - _last_sent).secs() >= static_cast<time_t>(_connection->get_hb_interval()))
-		{
+        if ((now - _last_sent).secs() >=
+            static_cast<time_t>(_connection->get_hb_interval())) {
             const f8String testReqID;
             send(generate_heartbeat(testReqID));
         }
 
         now.now();
-		if ((now - _last_received).secs() > static_cast<time_t>(_connection->get_hb_interval20pc()))
-		{
+        if ((now - _last_received).secs() >
+            static_cast<time_t>(_connection->get_hb_interval20pc())) {
             if (_state == States::st_test_request_sent)  // already sent
             {
                 ostringstream ostr;
                 ostr << "Remote has ignored my test request. Aborting session...";
-				send(generate_logout(_loginParameters._silent_disconnect ? 0 : ostr.str().c_str()), true, 0, true); // so it won't increment
+                send(generate_logout(
+                         _loginParameters._silent_disconnect ? 0 : ostr.str().c_str()),
+                     true, 0, true);  // so it won't increment
                 do_state_change(States::st_logoff_sent);
                 log(ostr.str(), Logger::Error);
-				try
-				{
-                    //  do not clear the timer, as the lock required for the same is already taken by the timer thread
-                    //  not removing the remaining events will cause some extra work to be done,
-                    //  but that work will be limited by the fact that the work checks if the session is already shutdown
-                    //  activation_service and heartbeat_service both have shutdown checks
+                try {
+                    //  do not clear the timer, as the lock required for the same is
+                    //  already taken by the timer thread not removing the remaining
+                    //  events will cause some extra work to be done, but that work will
+                    //  be limited by the fact that the work checks if the session is
+                    //  already shutdown activation_service and heartbeat_service both
+                    //  have shutdown checks
                     stop(false);
-				}
-				catch (Poco::Net::NetException& e)
-				{
+                } catch (Poco::Net::NetException &e) {
                     slout_error << e.what();
-				}
-				catch (exception& e)
-				{
+                } catch (exception &e) {
                     slout_error << e.what();
                 }
                 do_state_change(States::st_session_terminated);
                 return true;
-			}
-			else if (_state != States::st_session_terminated)
-			{
+            } else if (_state != States::st_session_terminated) {
                 ostringstream ostr;
                 ostr << "Have not received anything from remote for ";
                 if (_last_received.secs())
@@ -871,64 +823,54 @@ bool Session::heartbeat_service()
 }
 
 //-------------------------------------------------------------------------------------------------
-bool Session::handle_heartbeat(const unsigned seqnum, const Message *msg)
-{
+bool Session::handle_heartbeat(const unsigned seqnum, const Message *msg) {
     enforce(seqnum, msg);
 
-	if (_state == States::st_test_request_sent)
-		do_state_change(States::st_continuous);
+    if (_state == States::st_test_request_sent) do_state_change(States::st_continuous);
     return true;
 }
 
 //-------------------------------------------------------------------------------------------------
-Message *Session::generate_heartbeat(const f8String& testReqID)
-{
+Message *Session::generate_heartbeat(const f8String &testReqID) {
     Message *msg(create_msg(Common_MsgType_HEARTBEAT));
-	if (!testReqID.empty())
-		*msg << new test_request_id(testReqID);
+    if (!testReqID.empty()) *msg << new test_request_id(testReqID);
 
     return msg;
 }
 
 //-------------------------------------------------------------------------------------------------
-Message *Session::generate_reject(const unsigned seqnum, const char *what, const char *msgtype)
-{
+Message *Session::generate_reject(const unsigned seqnum, const char *what,
+                                  const char *msgtype) {
     Message *msg(create_msg(Common_MsgType_REJECT));
     *msg << new ref_seq_num(seqnum);
-	if (what)
-		*msg << new text(what);
-	if (msgtype)
-		*msg << new ref_msg_type(msgtype);
+    if (what) *msg << new text(what);
+    if (msgtype) *msg << new ref_msg_type(msgtype);
 
     return msg;
 }
 
 //-------------------------------------------------------------------------------------------------
-Message *Session::generate_business_reject(const unsigned seqnum, const Message *imsg, const int reason, const char *what)
-{
+Message *Session::generate_business_reject(const unsigned seqnum, const Message *imsg,
+                                           const int reason, const char *what) {
     Message *msg;
-	try
-	{
+    try {
         msg = create_msg(Common_MsgType_BUSINESS_REJECT);
-	}
-	catch (InvalidMetadata<f8String>&)
-	{
-		// since this is an application message, it may not be supported in supplied schema
+    } catch (InvalidMetadata<f8String> &) {
+        // since this is an application message, it may not be supported in supplied
+        // schema
         return nullptr;
     }
 
     *msg << new ref_seq_num(seqnum);
     *msg << new ref_msg_type(imsg->get_msgtype());
     *msg << new business_reject_reason(reason);
-	if (what)
-		*msg << new text(what);
+    if (what) *msg << new text(what);
 
     return msg;
 }
 
 //-------------------------------------------------------------------------------------------------
-Message *Session::generate_test_request(const f8String& testReqID)
-{
+Message *Session::generate_test_request(const f8String &testReqID) {
     Message *msg(create_msg(Common_MsgType_TEST_REQUEST));
     *msg << new test_request_id(testReqID);
 
@@ -936,32 +878,26 @@ Message *Session::generate_test_request(const f8String& testReqID)
 }
 
 //-------------------------------------------------------------------------------------------------
-Message *Session::generate_logon(const unsigned heartbtint, const f8String davi)
-{
+Message *Session::generate_logon(const unsigned heartbtint, const f8String davi) {
     Message *msg(create_msg(Common_MsgType_LOGON));
-	*msg << new heartbeat_interval(heartbtint)
-		  << new encrypt_method(0); // FIXME
+    *msg << new heartbeat_interval(heartbtint) << new encrypt_method(0);  // FIXME
     if (!davi.empty() && msg->is_legal<default_appl_ver_id>())
         *msg << new default_appl_ver_id(davi);
-	if (_loginParameters._reset_sequence_numbers)
-		*msg << new reset_seqnum_flag(true);
+    if (_loginParameters._reset_sequence_numbers) *msg << new reset_seqnum_flag(true);
 
     return msg;
 }
 
 //-------------------------------------------------------------------------------------------------
-Message *Session::generate_logout(const char *msgstr)
-{
+Message *Session::generate_logout(const char *msgstr) {
     Message *msg(create_msg(Common_MsgType_LOGOUT));
-	if (msgstr)
-		*msg << new text(msgstr);
+    if (msgstr) *msg << new text(msgstr);
 
     return msg;
 }
 
 //-------------------------------------------------------------------------------------------------
-Message *Session::generate_resend_request(const unsigned begin, const unsigned end)
-{
+Message *Session::generate_resend_request(const unsigned begin, const unsigned end) {
     Message *msg(create_msg(Common_MsgType_RESEND_REQUEST));
     *msg << new begin_seq_num(begin) << new end_seq_num(end);
 
@@ -969,69 +905,56 @@ Message *Session::generate_resend_request(const unsigned begin, const unsigned e
 }
 
 //-------------------------------------------------------------------------------------------------
-Message *Session::generate_sequence_reset(const unsigned newseqnum, const bool gapfillflag)
-{
+Message *Session::generate_sequence_reset(const unsigned newseqnum,
+                                          const bool gapfillflag) {
     Message *msg(create_msg(Common_MsgType_SEQUENCE_RESET));
     *msg << new new_seq_num(newseqnum);
 
-	if (gapfillflag)
-		*msg << new gap_fill_flag(true);
+    if (gapfillflag) *msg << new gap_fill_flag(true);
 
     return msg;
 }
 
 //-------------------------------------------------------------------------------------------------
-bool Session::send(Message *tosend, bool destroy, const unsigned custom_seqnum, const bool no_increment)
-{
-	if (custom_seqnum)
-		tosend->set_custom_seqnum(custom_seqnum);
-	if (no_increment)
-		tosend->set_no_increment(no_increment);
+bool Session::send(Message *tosend, bool destroy, const unsigned custom_seqnum,
+                   const bool no_increment) {
+    if (custom_seqnum) tosend->set_custom_seqnum(custom_seqnum);
+    if (no_increment) tosend->set_no_increment(no_increment);
     return _connection && _connection->write(tosend, destroy);
 }
 
-bool Session::send(Message& tosend, const unsigned custom_seqnum, const bool no_increment)
-{
-	if (custom_seqnum)
-		tosend.set_custom_seqnum(custom_seqnum);
-	if (no_increment)
-		tosend.set_no_increment(no_increment);
+bool Session::send(Message &tosend, const unsigned custom_seqnum,
+                   const bool no_increment) {
+    if (custom_seqnum) tosend.set_custom_seqnum(custom_seqnum);
+    if (no_increment) tosend.set_no_increment(no_increment);
     return _connection && _connection->write(tosend);
 }
 
 //-------------------------------------------------------------------------------------------------
-size_t Session::send_batch(const vector<Message *>& msgs, bool destroy)
-{
+size_t Session::send_batch(const vector<Message *> &msgs, bool destroy) {
     return _connection->write_batch(msgs, destroy);
 }
 
 //-------------------------------------------------------------------------------------------------
-int Session::modify_header(MessageBase *msg)
-{
-	return 0;
-}
+int Session::modify_header(MessageBase *msg) { return 0; }
 
 //-------------------------------------------------------------------------------------------------
-bool Session::send_process(Message *msg) // called from the connection (possibly on separate thread)
+bool Session::send_process(
+    Message *msg)  // called from the connection (possibly on separate thread)
 {
-	//cout << "send_process()" << endl;
+    cout << "send_process()" << endl;
     bool is_dup(msg->Header()->have(Common_PossDupFlag));
     if (!msg->Header()->have(Common_SenderCompID))
         *msg->Header() << new sender_comp_id(_sid.get_senderCompID());
     if (!msg->Header()->have(Common_TargetCompID))
         *msg->Header() << new target_comp_id(_sid.get_targetCompID());
 
-	if (msg->Header()->have(Common_MsgSeqNum))
-	{
-		if (is_dup)
-		{
+    if (msg->Header()->have(Common_MsgSeqNum)) {
+        if (is_dup) {
             if (_loginParameters._always_seqnum_assign)
                 delete msg->Header()->remove(Common_PossDupFlag);
-		}
-		else
-		{
-			if (!_loginParameters._always_seqnum_assign)
-			{
+        } else {
+            if (!_loginParameters._always_seqnum_assign) {
                 *msg->Header() << new poss_dup_flag(true);
                 is_dup = true;
             }
@@ -1041,84 +964,76 @@ bool Session::send_process(Message *msg) // called from the connection (possibly
         msg->Header()->get(sendtime);
         *msg->Header() << new orig_sending_time(sendtime());
 
-		if (_loginParameters._always_seqnum_assign)
-		{
+        if (_loginParameters._always_seqnum_assign) {
             slout_debug << "send_process: _next_send_seq = " << _next_send_seq;
-			*msg->Header() << new msg_seq_num(msg->get_custom_seqnum() ? msg->get_custom_seqnum() : static_cast<unsigned int>(_next_send_seq));
-		}
+            *msg->Header() << new msg_seq_num(
+                msg->get_custom_seqnum() ? msg->get_custom_seqnum()
+                                         : static_cast<unsigned int>(_next_send_seq));
         }
-	else
-	{
+    } else {
         slout_debug << "send_process: _next_send_seq = " << _next_send_seq;
-		*msg->Header() << new msg_seq_num(msg->get_custom_seqnum() ? msg->get_custom_seqnum() : static_cast<unsigned int>(_next_send_seq));
+        *msg->Header() << new msg_seq_num(
+            msg->get_custom_seqnum() ? msg->get_custom_seqnum()
+                                     : static_cast<unsigned int>(_next_send_seq));
     }
     *msg->Header() << new sending_time;
 
     // allow session to modify the header of this message before sending
     const int fields_modified(modify_header(msg->Header()));
-	if (fields_modified)
-	{
-		slout_debug << "send_process: " << fields_modified << " header fields added/modified";
+    if (fields_modified) {
+        slout_debug << "send_process: " << fields_modified
+                    << " header fields added/modified";
     }
 
-	try
-	{
+    try {
         slout_debug << "Sending:" << *msg;
         modify_outbound(msg);
         char output[FIX8_MAX_MSG_LENGTH + HEADER_CALC_OFFSET], *ptr(output);
         size_t enclen(msg->encode(&ptr));
         const char *optr(ptr);
-		if (msg->get_end_of_batch())
-		{
-			if (!_batchmsgs_buffer.empty())
-			{
+
+        if (msg->get_end_of_batch()) {
+            if (!_batchmsgs_buffer.empty()) {
                 _batchmsgs_buffer.append(ptr);
                 ptr = &_batchmsgs_buffer[0];
                 enclen = _batchmsgs_buffer.size();
             }
-			if (!_connection->send(ptr, enclen))
-			{
+            if (!_connection->send(ptr, enclen)) {
                 slout_error << "Message write failed: " << enclen << " bytes";
                 _batchmsgs_buffer.clear();
                 return false;
             }
             _last_sent.now();
             _batchmsgs_buffer.clear();
-		}
-		else
-		{
+        } else {
             _batchmsgs_buffer.append(ptr);
         }
 
-		if (_plogger && _plogger->has_flag(Logger::outbound))
-			plog(optr, Logger::Info);
+        if (_plogger && _plogger->has_flag(Logger::outbound)) plog(optr, Logger::Info);
 
         // cout << "send_process" << endl;
 
-		if (!is_dup)
-		{
-			if (_persist)
-			{
-				f8_scoped_spin_lock guard(_per_spl, _connection->get_pmodel() == pm_coro); // not needed for coroutine mode
-				if (!msg->is_admin())
-					_persist->put(_next_send_seq, ptr);
+        if (!is_dup) {
+            if (_persist) {
+                f8_scoped_spin_lock guard(
+                    _per_spl, _connection->get_pmodel() ==
+                                  pm_coro);  // not needed for coroutine mode
+                if (!msg->is_admin()) _persist->put(_next_send_seq, ptr);
                 _persist->put(_next_send_seq + 1, _next_receive_seq);
-				//cout << "Persisted (send):" << (_next_send_seq + 1) << " and " << _next_receive_seq << endl;
+                // cout << "Persisted (send):" << (_next_send_seq + 1) << " and " <<
+                // _next_receive_seq << endl;
             }
-			if (!msg->get_custom_seqnum() && !msg->get_no_increment() && msg->get_msgtype() != Common_MsgType_SEQUENCE_RESET)
-			{
+            if (!msg->get_custom_seqnum() && !msg->get_no_increment() &&
+                msg->get_msgtype() != Common_MsgType_SEQUENCE_RESET) {
                 ++_next_send_seq;
-				//cout << "Seqnum now:" << _next_send_seq << " and " << _next_receive_seq << endl;
+                // cout << "Seqnum now:" << _next_send_seq << " and " <<
+                // _next_receive_seq << endl;
             }
         }
-	}
-	catch (f8Exception& e)
-	{
+    } catch (f8Exception &e) {
         slout_error << e.what();
         return false;
-	}
-	catch (Poco::Exception& e)
-	{
+    } catch (Poco::Exception &e) {
         slout_error << e.displayText();
         return false;
     }
@@ -1127,15 +1042,13 @@ bool Session::send_process(Message *msg) // called from the connection (possibly
 }
 
 //-------------------------------------------------------------------------------------------------
-void Session::recover_seqnums()
-{
+void Session::recover_seqnums() {
     f8_scoped_spin_lock guard(_per_spl, _connection->get_pmodel() == pm_coro);
-	if (_persist)
-	{
+    if (_persist) {
         unsigned send_seqnum, receive_seqnum;
-		if (_persist->get(send_seqnum, receive_seqnum))
-		{
-			slout_info << "Last sent: " << send_seqnum << ", last received: " << receive_seqnum;
+        if (_persist->get(send_seqnum, receive_seqnum)) {
+            slout_info << "Last sent: " << send_seqnum
+                       << ", last received: " << receive_seqnum;
             _next_send_seq = send_seqnum;        // + 1;
             _next_receive_seq = receive_seqnum;  // + 1;
         }
@@ -1143,32 +1056,33 @@ void Session::recover_seqnums()
 }
 
 //-------------------------------------------------------------------------------------------------
-#if (FIX8_THREAD_SYSTEM == FIX8_THREAD_PTHREAD) && !defined _MSC_VER && defined _GNU_SOURCE && defined __linux__
-f8String Session::get_thread_policy_string(thread_id_t id)
-{
+#if (FIX8_THREAD_SYSTEM == FIX8_THREAD_PTHREAD) && !defined _MSC_VER && \
+    defined _GNU_SOURCE && defined __linux__
+f8String Session::get_thread_policy_string(thread_id_t id) {
     int policy;
     ostringstream ostr;
     sched_param param{};
     if (!pthread_getschedparam(id, &policy, &param))
-		return policy == SCHED_OTHER ? "SCHED_OTHER" : policy == SCHED_RR ? "SCHED_RR"
-			  : policy == SCHED_FIFO ? "SCHED_FIFO" : "UNKNOWN";
+        return policy == SCHED_OTHER  ? "SCHED_OTHER"
+               : policy == SCHED_RR   ? "SCHED_RR"
+               : policy == SCHED_FIFO ? "SCHED_FIFO"
+                                      : "UNKNOWN";
 
     ostr << "Could not get scheduler parameters: " << Str_error(errno);
     return ostr.str();
 }
 
 //-------------------------------------------------------------------------------------------------
-void Session::set_scheduler(int priority)
-{
+void Session::set_scheduler(int priority) {
     pthread_t thread(pthread_self());
     sched_param param{priority};
 
     slout_info << "Current scheduler policy: " << get_thread_policy_string(thread);
 
-   if (pthread_setschedparam(thread, SCHED_RR, &param))
-	{
-		slout_error << "Could not set new scheduler priority: " << get_thread_policy_string(thread)
-			<< " (" << Str_error(errno) << ") " << priority;
+    if (pthread_setschedparam(thread, SCHED_RR, &param)) {
+        slout_error << "Could not set new scheduler priority: "
+                    << get_thread_policy_string(thread) << " (" << Str_error(errno)
+                    << ") " << priority;
         return;
     }
 
@@ -1176,11 +1090,9 @@ void Session::set_scheduler(int priority)
 }
 
 //-------------------------------------------------------------------------------------------------
-void Session::set_affinity(int core_id)
-{
+void Session::set_affinity(int core_id) {
     const int num_cores(sysconf(_SC_NPROCESSORS_ONLN));
-   if (core_id >= num_cores)
-	{
+    if (core_id >= num_cores) {
         slout_error << "Invalid core id: " << core_id;
         return;
     }
@@ -1191,27 +1103,26 @@ void Session::set_affinity(int core_id)
     const int error(pthread_setaffinity_np(pthread_self(), sizeof(cpu_set_t), &cpuset));
 
     if (error)
-		slout_error << "Could not set thread affinity for core " << core_id << " (" << Str_error(errno) << ')';
+        slout_error << "Could not set thread affinity for core " << core_id << " ("
+                    << Str_error(errno) << ')';
     else
-		slout_info << "Set thread affinity to " << core_id << " core for thread " << pthread_self();
+        slout_info << "Set thread affinity to " << core_id << " core for thread "
+                   << pthread_self();
 }
 #else
 //-------------------------------------------------------------------------------------------------
-void Session::set_scheduler(int priority)
-{
+void Session::set_scheduler(int priority) {
     slout_error << "set_scheduler: not implemented";
 }
 
 //-------------------------------------------------------------------------------------------------
-void Session::set_affinity(int core_id)
-{
+void Session::set_affinity(int core_id) {
     slout_error << "set_affinity: not implemented";
 }
 #endif
 
 //-------------------------------------------------------------------------------------------------
-const f8String Session::copyright_string()
-{
+const f8String Session::copyright_string() {
     time_t now(time(0));
 #ifdef _MSC_VER
     struct tm *ptim(localtime(&now));
@@ -1221,27 +1132,29 @@ const f8String Session::copyright_string()
     struct tm *ptim(&tim);
 #endif
     ostringstream ostr;
-	ostr << endl << package_version << ' ' << copyright_short << setw(2) << (ptim->tm_year - 100) << copyright_short2;
+    ostr << endl
+         << package_version << ' ' << copyright_short << setw(2)
+         << (ptim->tm_year - 100) << copyright_short2;
     return ostr.str();
 }
 
-
 //-------------------------------------------------------------------------------------------------
 #ifdef FIX8_HAVE_OPENSSL
-void Fix8CertificateHandler::onInvalidCertificate(const void*, Poco::Net::VerificationErrorArgs& errorCert)
-{
+void Fix8CertificateHandler::onInvalidCertificate(
+    const void *, Poco::Net::VerificationErrorArgs &errorCert) {
     const Poco::Net::X509Certificate &cert(errorCert.certificate());
     glout_warn << "WARNING: Certificate verification failed";
     glout_warn << "----------------------------------------";
     glout_warn << "Issuer Name:  " << cert.issuerName();
     glout_warn << "Subject Name: " << cert.subjectName();
     glout_warn << "The certificate yielded the error: " << errorCert.errorMessage();
-	glout_warn << "The error occurred in the certificate chain at position " << errorCert.errorDepth();
+    glout_warn << "The error occurred in the certificate chain at position "
+               << errorCert.errorDepth();
     errorCert.setIgnoreError(true);
 }
 
-void Fix8PassPhraseHandler::onPrivateKeyRequested(const void*, std::string& privateKey)
-{
+void Fix8PassPhraseHandler::onPrivateKeyRequested(const void *,
+                                                  std::string &privateKey) {
     glout_warn << "warning: privatekey passphrase requested and ignored!";
 }
 
diff --git a/test/hftest.cpp b/test/hftest.cpp
index 8a01a5d..fe74765 100644
--- a/test/hftest.cpp
+++ b/test/hftest.cpp
@@ -6,31 +6,34 @@ Fix8 is released under the GNU LESSER GENERAL PUBLIC LICENSE Version 3.
 Fix8 Open Source FIX Engine.
 Copyright (C) 2010-19 David L. Dight <fix@fix8.org>
 
-Fix8 is free software: you can  redistribute it and / or modify  it under the  terms of the
-GNU Lesser General  Public License as  published  by the Free  Software Foundation,  either
-version 3 of the License, or (at your option) any later version.
-
-Fix8 is distributed in the hope  that it will be useful, but WITHOUT ANY WARRANTY;  without
-even the  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-
-You should  have received a copy of the GNU Lesser General Public  License along with Fix8.
-If not, see <http://www.gnu.org/licenses/>.
-
-BECAUSE THE PROGRAM IS  LICENSED FREE OF  CHARGE, THERE IS NO  WARRANTY FOR THE PROGRAM, TO
-THE EXTENT  PERMITTED  BY  APPLICABLE  LAW.  EXCEPT WHEN  OTHERWISE  STATED IN  WRITING THE
-COPYRIGHT HOLDERS AND/OR OTHER PARTIES  PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY
-KIND,  EITHER EXPRESSED   OR   IMPLIED,  INCLUDING,  BUT   NOT  LIMITED   TO,  THE  IMPLIED
-WARRANTIES  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO
-THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE,
-YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-IN NO EVENT UNLESS REQUIRED  BY APPLICABLE LAW  OR AGREED TO IN  WRITING WILL ANY COPYRIGHT
-HOLDER, OR  ANY OTHER PARTY  WHO MAY MODIFY  AND/OR REDISTRIBUTE  THE PROGRAM AS  PERMITTED
-ABOVE,  BE  LIABLE  TO  YOU  FOR  DAMAGES,  INCLUDING  ANY  GENERAL, SPECIAL, INCIDENTAL OR
-CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT
-NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR
-THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH
-HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+Fix8 is free software: you can  redistribute it and / or modify  it under the  terms of
+the GNU Lesser General  Public License as  published  by the Free  Software Foundation,
+either version 3 of the License, or (at your option) any later version.
+
+Fix8 is distributed in the hope  that it will be useful, but WITHOUT ANY WARRANTY;
+without even the  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+PURPOSE.
+
+You should  have received a copy of the GNU Lesser General Public  License along with
+Fix8. If not, see <http://www.gnu.org/licenses/>.
+
+BECAUSE THE PROGRAM IS  LICENSED FREE OF  CHARGE, THERE IS NO  WARRANTY FOR THE PROGRAM,
+TO THE EXTENT  PERMITTED  BY  APPLICABLE  LAW.  EXCEPT WHEN  OTHERWISE  STATED IN
+WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES  PROVIDE THE PROGRAM "AS IS" WITHOUT
+WARRANTY OF ANY KIND,  EITHER EXPRESSED   OR   IMPLIED,  INCLUDING,  BUT   NOT  LIMITED
+TO,  THE  IMPLIED WARRANTIES  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
+CORRECTION.
+
+IN NO EVENT UNLESS REQUIRED  BY APPLICABLE LAW  OR AGREED TO IN  WRITING WILL ANY
+COPYRIGHT HOLDER, OR  ANY OTHER PARTY  WHO MAY MODIFY  AND/OR REDISTRIBUTE  THE PROGRAM
+AS  PERMITTED ABOVE,  BE  LIABLE  TO  YOU  FOR  DAMAGES,  INCLUDING  ANY  GENERAL,
+SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
+THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE
+OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH
+ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
 
 */
 
@@ -43,12 +46,10 @@ HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
         Usage: hftest [-RSchlqrsv]\n
                 -R,--receive            set next expected receive sequence number\n
                 -S,--send               set next send sequence number\n
-		-c,--config             xml config (default: hf_client.xml or hf_server.xml)\n
-		-h,--help               help, this screen\n
-		-l,--log                global log filename\n
-		-q,--quiet              do not print fix output\n
-		-u,--update             update interval for console counters (default 5000)\n
-		-r,--reliable           start in reliable mode\n
+                -c,--config             xml config (default: hf_client.xml or
+hf_server.xml)\n -h,--help               help, this screen\n -l,--log global log
+filename\n -q,--quiet              do not print fix output\n -u,--update update interval
+for console counters (default 5000)\n -r,--reliable           start in reliable mode\n
                 -s,--server             run in server mode (default client mode)\n
                 -v,--version            print version then exit\n
 </tt>
@@ -72,7 +73,8 @@ HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
   2. The client has a simple menu. Press ? to see options.\n
   3. The server will wait for the client to logout before exiting.\n
   4. Press P to preload NewOrderSingle messages, T to transmit them.\n
-  5. The server uses \c hf_client.xml and the client uses \c hf_server.xml for configuration settings. \n
+  5. The server uses \c hf_client.xml and the client uses \c hf_server.xml for
+configuration settings. \n
   6. The example uses \c FIX42.xml \n
 \n
 */
@@ -82,29 +84,29 @@ HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
 */
 
 /*! \namespace FIX8::TEX
-	This namespace is used by the generated classes and types, and was specified as a namespace
-	to the \c f8c compiler.
+        This namespace is used by the generated classes and types, and was specified as
+   a namespace to the \c f8c compiler.
 */
 
 //-----------------------------------------------------------------------------------------
-#include <iostream>
-#include <memory>
+#include <algorithm>
 #include <fstream>
 #include <iomanip>
-#include <sstream>
-#include <vector>
-#include <map>
+#include <iostream>
+#include <iterator>
 #include <list>
+#include <map>
+#include <memory>
 #include <set>
-#include <iterator>
-#include <algorithm>
+#include <sstream>
 #include <typeinfo>
+#include <vector>
 #ifdef _MSC_VER
-#include <signal.h>
 #include <conio.h>
+#include <signal.h>
 #else
-#include <sys/ioctl.h>
 #include <signal.h>
+#include <sys/ioctl.h>
 #include <termios.h>
 #endif
 
@@ -122,10 +124,9 @@ HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
 #if defined(FIX8_CODECTIMING)
 #include <fix8/f8measure.hpp>
 #endif
-#include "Perf_types.hpp"
-#include "Perf_router.hpp"
 #include "Perf_classes.hpp"
-
+#include "Perf_router.hpp"
+#include "Perf_types.hpp"
 #include "hftest.hpp"
 
 //-----------------------------------------------------------------------------------------
@@ -138,10 +139,8 @@ bool term_received(false);
 unsigned batch_size(1000), preload_count(0), update_count(5000);
 
 //-----------------------------------------------------------------------------------------
-struct performance_metrics
-{
-	enum Enum
-	{
+struct performance_metrics {
+    enum Enum {
         msg_create,
         msg_send,
         msg_destroy,
@@ -155,8 +154,14 @@ struct performance_metrics
 FIX8::stop_watch perf_metric(performance_metrics::_max);
 void perf_metric_start(performance_metrics::Enum what) { perf_metric.start(what); }
 void perf_metric_stop(performance_metrics::Enum what) { perf_metric.stop(what); }
-void perf_metric_start(performance_metrics::Enum what, FIX8::stop_watch::ticks_t measure) { perf_metric.start(what, measure); }
-void perf_metric_stop(performance_metrics::Enum what, FIX8::stop_watch::ticks_t measure) { perf_metric.stop(what, measure); }
+void perf_metric_start(performance_metrics::Enum what,
+                       FIX8::stop_watch::ticks_t measure) {
+    perf_metric.start(what, measure);
+}
+void perf_metric_stop(performance_metrics::Enum what,
+                      FIX8::stop_watch::ticks_t measure) {
+    perf_metric.stop(what, measure);
+}
 FIX8::stop_watch::ticks_t perf_metric_measure() { return FIX8::stop_watch::measure(); }
 #else
 void perf_metric_start(performance_metrics::Enum what) {}
@@ -167,8 +172,7 @@ std::int64_t perf_metric_measure() { return 0; }
 #endif
 
 //-----------------------------------------------------------------------------------------
-void report_perf_metric(const std::string& prefix)
-{
+void report_perf_metric(const std::string &prefix) {
 #if defined FIX8_CODECTIMING
     using namespace FIX8;
 
@@ -176,26 +180,26 @@ void report_perf_metric(const std::string& prefix)
     ostr.setf(std::ios::showpoint);
     ostr.setf(std::ios::fixed);
 
-	if (perf_metric.val(performance_metrics::msg_create)[stop_watch::value::_count])
-	{
+    if (perf_metric.val(performance_metrics::msg_create)[stop_watch::value::_count]) {
         ostr << prefix << ' ';
-		Message::format_codec_timings("Create", ostr, perf_metric.val(performance_metrics::msg_create));
+        Message::format_codec_timings("Create", ostr,
+                                      perf_metric.val(performance_metrics::msg_create));
         glout_info << ostr.str();
     }
 
-	if (perf_metric.val(performance_metrics::msg_send)[stop_watch::value::_count])
-	{
+    if (perf_metric.val(performance_metrics::msg_send)[stop_watch::value::_count]) {
         ostr.str("");
         ostr << prefix << ' ';
-		Message::format_codec_timings("Send", ostr, perf_metric.val(performance_metrics::msg_send));
+        Message::format_codec_timings("Send", ostr,
+                                      perf_metric.val(performance_metrics::msg_send));
         glout_info << ostr.str();
     }
 
-	if (perf_metric.val(performance_metrics::msg_destroy)[stop_watch::value::_count])
-	{
+    if (perf_metric.val(performance_metrics::msg_destroy)[stop_watch::value::_count]) {
         ostr.str("");
         ostr << prefix << ' ';
-		Message::format_codec_timings("Destroy", ostr, perf_metric.val(performance_metrics::msg_destroy));
+        Message::format_codec_timings(
+            "Destroy", ostr, perf_metric.val(performance_metrics::msg_destroy));
         glout_info << ostr.str();
     }
 #if 0
@@ -219,11 +223,11 @@ void report_perf_metric(const std::string& prefix)
 }
 
 //-----------------------------------------------------------------------------------------
-const MyMenu::Handlers MyMenu::_handlers
-{
+const MyMenu::Handlers MyMenu::_handlers{
     {{'n', "Send a NewOrderSingle msg"}, &MyMenu::new_order_single},
     {{'p', "Preload n NewOrderSingle msgs"}, &MyMenu::preload_new_order_single},
-	{ { 'b', "Batch preload and send n NewOrderSingle msgs" }, &MyMenu::batch_preload_new_order_single },
+    {{'b', "Batch preload and send n NewOrderSingle msgs"},
+     &MyMenu::batch_preload_new_order_single},
     {{'N', "Send n NewOrderSingle msgs"}, &MyMenu::multi_new_order_single},
     {{'a', "Send all Preloaded NewOrderSingle msgs"}, &MyMenu::send_all_preloaded},
     {{'?', "Help"}, &MyMenu::help},
@@ -234,10 +238,8 @@ const MyMenu::Handlers MyMenu::_handlers
 bool quiet(true);
 
 //-----------------------------------------------------------------------------------------
-void sig_handler(int sig)
-{
-   switch (sig)
-   {
+void sig_handler(int sig) {
+    switch (sig) {
         case SIGTERM:
         case SIGINT:
 #ifndef _MSC_VER
@@ -253,30 +255,21 @@ void sig_handler(int sig)
 }
 
 //-----------------------------------------------------------------------------------------
-int main(int argc, char **argv)
-{
+int main(int argc, char **argv) {
     int val;
     bool server(false), once(false), reliable(false);
     string clcf;
     unsigned next_send(0), next_receive(0);
 
 #ifdef FIX8_HAVE_GETOPT_LONG
-	option long_options[]
-	{
-		{ "help",		0,	0,	'h' },
-		{ "version",	0,	0,	'v' },
-		{ "once",	   0,	0,	'o' },
-		{ "log",			1,	0,	'l' },
-		{ "config",		1,	0,	'c' },
-		{ "server",		0,	0,	's' },
-		{ "batch",		1,	0,	'b' },
-		{ "send",		1,	0,	'S' },
-		{ "receive",	1,	0,	'R' },
-		{ "quiet",		0,	0,	'q' },
-		{ "reliable",	0,	0,	'r' },
-		{ "preload",	1,	0,	'p' },
-		{ "update",		1,	0,	'u' },
-		{ 0 },
+    option long_options[]{
+        {"help", 0, 0, 'h'},     {"version", 0, 0, 'v'},
+        {"once", 0, 0, 'o'},     {"log", 1, 0, 'l'},
+        {"config", 1, 0, 'c'},   {"server", 0, 0, 's'},
+        {"batch", 1, 0, 'b'},    {"send", 1, 0, 'S'},
+        {"receive", 1, 0, 'R'},  {"quiet", 0, 0, 'q'},
+        {"reliable", 0, 0, 'r'}, {"preload", 1, 0, 'p'},
+        {"update", 1, 0, 'u'},   {0},
     };
 
     while ((val = getopt_long(argc, argv, GETARGLIST.c_str(), long_options, 0)) != -1)
@@ -284,26 +277,55 @@ int main(int argc, char **argv)
     while ((val = getopt(argc, argv, GETARGLIST.c_str())) != -1)
 #endif
     {
-      switch (val)
-		{
+        switch (val) {
             case 'v':
-			cout << argv[0] << " for " FIX8_PACKAGE " version " FIX8_VERSION << endl;
-			cout << "Released under the GNU LESSER GENERAL PUBLIC LICENSE, Version 3. See <http://fsf.org/> for details." << endl;
+                cout << argv[0] << " for " FIX8_PACKAGE " version " FIX8_VERSION
+                     << endl;
+                cout << "Released under the GNU LESSER GENERAL PUBLIC LICENSE, Version "
+                        "3. See <http://fsf.org/> for details."
+                     << endl;
                 return 0;
-		case ':': case '?': return 1;
-		case 'h': print_usage(); return 0;
-		case 'l': FIX8::GlobalLogger::set_global_filename(optarg); break;
-		case 'c': clcf = optarg; break;
-		case 'b': batch_size = stoul(optarg); break;
-		case 'p': preload_count = stoul(optarg); break;
-		case 'u': update_count = stoul(optarg); break;
-		case 's': server = true; break;
-		case 'o': once = true; break;
-		case 'S': next_send = stoul(optarg); break;
-		case 'R': next_receive = stoul(optarg); break;
-		case 'q': quiet = false; break;
-		case 'r': reliable = true; break;
-		default: break;
+            case ':':
+            case '?':
+                return 1;
+            case 'h':
+                print_usage();
+                return 0;
+            case 'l':
+                FIX8::GlobalLogger::set_global_filename(optarg);
+                break;
+            case 'c':
+                clcf = optarg;
+                break;
+            case 'b':
+                batch_size = stoul(optarg);
+                break;
+            case 'p':
+                preload_count = stoul(optarg);
+                break;
+            case 'u':
+                update_count = stoul(optarg);
+                break;
+            case 's':
+                server = true;
+                break;
+            case 'o':
+                once = true;
+                break;
+            case 'S':
+                next_send = stoul(optarg);
+                break;
+            case 'R':
+                next_receive = stoul(optarg);
+                break;
+            case 'q':
+                quiet = false;
+                break;
+            case 'r':
+                reliable = true;
+                break;
+            default:
+                break;
         }
     }
 
@@ -315,29 +337,30 @@ int main(int argc, char **argv)
     signal(SIGQUIT, sig_handler);
 #endif
 
-	try
-	{
-		const string conf_file(server ? clcf.empty() ? "hf_server.xml" : clcf : clcf.empty() ? "hf_client.xml" : clcf);
+    try {
+        const string conf_file(server         ? clcf.empty() ? "hf_server.xml" : clcf
+                               : clcf.empty() ? "hf_client.xml"
+                                              : clcf);
 
-		if (server)
-		{
-			unique_ptr<FIX8::ServerSessionBase> ms(new FIX8::ServerSession<hf_session_server>(FIX8::TEX::ctx(), conf_file, "TEX1"));
+        if (server) {
+            unique_ptr<FIX8::ServerSessionBase> ms(
+                new FIX8::ServerSession<hf_session_server>(FIX8::TEX::ctx(), conf_file,
+                                                           "TEX1"));
 
             XmlElement::XmlSet eset;
 
-			for (unsigned scnt(0); !term_received; )
-			{
-				if (!ms->poll())
-					continue;
-				unique_ptr<FIX8::SessionInstanceBase> inst(ms->create_server_instance());
-				if (!quiet)
-					inst->session_ptr()->control() |= FIX8::Session::print;
+            for (unsigned scnt(0); !term_received;) {
+                if (!ms->poll()) continue;
+                unique_ptr<FIX8::SessionInstanceBase> inst(
+                    ms->create_server_instance());
+                if (!quiet) inst->session_ptr()->control() |= FIX8::Session::print;
                 ostringstream sostr;
                 sostr << "client(" << ++scnt << ") connection established.";
                 FIX8::GlobalLogger::log(sostr.str());
                 const FIX8::ProcessModel pm(ms->get_process_model(ms->_ses));
                 inst->start(pm == FIX8::pm_pipeline, next_send, next_receive);
-				cout << (pm == FIX8::pm_pipeline ? "Pipelined" : "Threaded") << " mode." << endl;
+                cout << (pm == FIX8::pm_pipeline ? "Pipelined" : "Threaded") << " mode."
+                     << endl;
                 if (inst->session_ptr()->get_connection()->is_secure())
                     cout << "Session is secure (SSL)" << endl;
                 if (pm != FIX8::pm_pipeline)
@@ -349,21 +372,20 @@ int main(int argc, char **argv)
                 report_perf_metric("server");
 #endif
                 inst->stop();
-				if (once)
-					break;
+                if (once) break;
             }
-		}
-		else
-		{
-			unique_ptr<FIX8::ClientSessionBase>
-				mc(reliable ? new FIX8::ReliableClientSession<hf_session_client>(FIX8::TEX::ctx(), conf_file, "DLD1")
-							   : new FIX8::ClientSession<hf_session_client>(FIX8::TEX::ctx(), conf_file, "DLD1"));
-			if (!quiet)
-				mc->session_ptr()->control() |= FIX8::Session::print;
+        } else {
+            unique_ptr<FIX8::ClientSessionBase> mc(
+                reliable ? new FIX8::ReliableClientSession<hf_session_client>(
+                               FIX8::TEX::ctx(), conf_file, "DLD1")
+                         : new FIX8::ClientSession<hf_session_client>(
+                               FIX8::TEX::ctx(), conf_file, "DLD1"));
+            if (!quiet) mc->session_ptr()->control() |= FIX8::Session::print;
 
             const FIX8::ProcessModel pm(mc->get_process_model(mc->_ses));
             if (!reliable)
-				mc->start(false, next_send, next_receive, mc->session_ptr()->get_login_parameters()._davi());
+                mc->start(false, next_send, next_receive,
+                          mc->session_ptr()->get_login_parameters()._davi());
             else
                 mc->start(false, next_send, next_receive);
 
@@ -371,78 +393,63 @@ int main(int argc, char **argv)
             cout << endl << "Menu started. Press '?' for help..." << endl << endl;
             if (mc->session_ptr()->get_connection()->is_secure())
                 cout << "Session is secure (SSL)" << endl;
-			if (preload_count)
-				mymenu.preload_new_order_single();
+            if (preload_count) mymenu.preload_new_order_single();
             char ch;
             mymenu.get_tty().set_raw_mode();
-			if (pm == FIX8::pm_coro)
-			{
+            if (pm == FIX8::pm_coro) {
                 cout << "Coroutine mode." << endl;
                 fd_set rfds;
                 timeval tv{};
 
-				while (!term_received)
-				{
+                while (!term_received) {
                     mc->session_ptr()->get_connection()->reader_execute();
                     char ch(0);
                     FD_ZERO(&rfds);
                     FD_SET(0, &rfds);
 #ifdef _MSC_VER
-					if (kbhit())
-					{
+                    if (kbhit()) {
                         ch = getch();
 #else
-					if (select(1, &rfds, 0, 0, &tv) > 0)
-					{
-						if (read (0, &ch, 1) < 0)
-							break;
+                    if (select(1, &rfds, 0, 0, &tv) > 0) {
+                        if (read(0, &ch, 1) < 0) break;
 #endif
-						if (ch == 'a')
-						{
+                        if (ch == 'a') {
                             cout << "Sending messages..." << endl;
                             coroutine coro;
                             while (mymenu.send_all_preloaded(coro, mc->session_ptr()))
                                 mc->session_ptr()->get_connection()->reader_execute();
-						}
-						else if (ch == 0x3 || !mymenu.process(ch))
+                        } else if (ch == 0x3 || !mymenu.process(ch))
                             break;
                     }
                 }
-			}
-			else
-			{
-				cout << (pm == FIX8::pm_pipeline ? "Pipelined" : "Threaded") << " mode." << endl;
-				while(!mymenu.get_istr().get(ch).bad() && !term_received && ch != 0x3 && mymenu.process(ch))
-					;
+            } else {
+                cout << (pm == FIX8::pm_pipeline ? "Pipelined" : "Threaded") << " mode."
+                     << endl;
+                while (!mymenu.get_istr().get(ch).bad() && !term_received &&
+                       ch != 0x3 && mymenu.process(ch));
             }
             cout << endl;
 #if defined FIX8_CODECTIMING
             FIX8::Message::report_codec_timings("client");
             report_perf_metric("client");
 #endif
-			if (!mc->session_ptr()->is_shutdown())
-				mc->session_ptr()->stop();
+            if (!mc->session_ptr()->is_shutdown()) mc->session_ptr()->stop();
 
             mymenu.get_tty().unset_raw_mode();
         }
-	}
-	catch (FIX8::f8Exception& e)
-	{
+    } catch (FIX8::f8Exception &e) {
         cerr << "exception: " << e.what() << endl;
-	}
-	catch (exception& e)	// also catches Poco::Net::NetException
+    } catch (exception &e)  // also catches Poco::Net::NetException
     {
         cerr << "exception: " << e.what() << endl;
     }
 
-	if (term_received)
-		cout << "terminated." << endl;
+    if (term_received) cout << "terminated." << endl;
     return 0;
 }
 
 //-----------------------------------------------------------------------------------------
-void send_msg(FIX8::Message* msg, FIX8::Session& session)
-{
+void send_msg(FIX8::Message *msg, FIX8::Session &session) {
     std::unique_ptr<FIX8::Message> msg_ptr{msg};
     perf_metric_start(performance_metrics::msg_send);
     session.send(msg, false);
@@ -454,35 +461,33 @@ void send_msg(FIX8::Message* msg, FIX8::Session& session)
 }
 
 //-----------------------------------------------------------------------------------------
-bool MyMenu::batch_preload_new_order_single()
-{
+bool MyMenu::batch_preload_new_order_single() {
     unsigned num(preload_count);
-	if (!num)
-	{
+    if (!num) {
         cout << "Enter number of NewOrderSingle msgs to batch preload:";
         cout.flush();
         _tty.unset_raw_mode();
         cin >> num;
         _tty.set_raw_mode();
     }
-	while (num > 0)
-	{
+    while (num > 0) {
         unsigned cnt(0);
-		for (; cnt < num && cnt < batch_size; ++cnt)
-		{
+        for (; cnt < num && cnt < batch_size; ++cnt) {
             static unsigned oid(10000);
             ostringstream oistr;
             oistr << "ord" << ++oid << '-' << num;
 
             perf_metric_start(performance_metrics::msg_create);
             FIX8::TEX::NewOrderSingle *ptr(new FIX8::TEX::NewOrderSingle);
-			*ptr << new FIX8::TEX::Symbol("BHP")
-				  << new FIX8::TEX::HandlInst(FIX8::TEX::HandlInst_AUTOMATED_EXECUTION_ORDER_PRIVATE_NO_BROKER_INTERVENTION)
+            *ptr
+                << new FIX8::TEX::Symbol("BHP")
+                << new FIX8::TEX::HandlInst(
+                       FIX8::TEX::
+                           HandlInst_AUTOMATED_EXECUTION_ORDER_PRIVATE_NO_BROKER_INTERVENTION)
                 << new FIX8::TEX::OrdType(FIX8::TEX::OrdType_LIMIT)
                 << new FIX8::TEX::Side(FIX8::TEX::Side_BUY)
                 << new FIX8::TEX::TimeInForce(FIX8::TEX::TimeInForce_FILL_OR_KILL)
-				  << new FIX8::TEX::TransactTime
-				  << new FIX8::TEX::ClOrdID(oistr.str())
+                << new FIX8::TEX::TransactTime << new FIX8::TEX::ClOrdID(oistr.str())
                 << new FIX8::TEX::Price(1. + RandDev::getrandom(500.), 3)
                 << new FIX8::TEX::OrderQty(1 + RandDev::getrandom(10000));
             perf_metric_stop(performance_metrics::msg_create);
@@ -501,24 +506,21 @@ bool MyMenu::batch_preload_new_order_single()
 }
 
 //-----------------------------------------------------------------------------------------
-bool MyMenu::multi_new_order_single()
-{
+bool MyMenu::multi_new_order_single() {
     cout << "Enter number of NewOrderSingle msgs to send:";
     cout.flush();
     unsigned num(0);
     _tty.unset_raw_mode();
     cin >> num;
     _tty.set_raw_mode();
-	for (unsigned ii(0); ii < num; ++ii)
-		new_order_single();
+    for (unsigned ii(0); ii < num; ++ii) new_order_single();
     cout << endl << num << " NewOrderSingle msgs sent" << endl;
 
     return true;
 }
 
 //-----------------------------------------------------------------------------------------
-bool MyMenu::new_order_single()
-{
+bool MyMenu::new_order_single() {
     static unsigned oid(0);
     ostringstream oistr;
     oistr << "ord" << ++oid;
@@ -528,9 +530,10 @@ bool MyMenu::new_order_single()
     *nos << new FIX8::TEX::TransactTime
          << new FIX8::TEX::OrderQty(1 + RandDev::getrandom(10000))
          << new FIX8::TEX::Price(1. + RandDev::getrandom(500.))
-			<< new FIX8::TEX::ClOrdID(oistr.str())
-			<< new FIX8::TEX::Symbol("BHP")
-			<< new FIX8::TEX::HandlInst(FIX8::TEX::HandlInst_AUTOMATED_EXECUTION_ORDER_PRIVATE_NO_BROKER_INTERVENTION)
+         << new FIX8::TEX::ClOrdID(oistr.str()) << new FIX8::TEX::Symbol("BHP")
+         << new FIX8::TEX::HandlInst(
+                FIX8::TEX::
+                    HandlInst_AUTOMATED_EXECUTION_ORDER_PRIVATE_NO_BROKER_INTERVENTION)
          << new FIX8::TEX::OrdType(FIX8::TEX::OrdType_LIMIT)
          << new FIX8::TEX::Side(FIX8::TEX::Side_BUY)
          << new FIX8::TEX::TimeInForce(FIX8::TEX::TimeInForce_FILL_OR_KILL);
@@ -541,19 +544,15 @@ bool MyMenu::new_order_single()
 }
 
 //-----------------------------------------------------------------------------------------
-bool MyMenu::send_all_preloaded()
-{
+bool MyMenu::send_all_preloaded() {
     const unsigned tosend(_session.size());
     cout << "Sending " << tosend << " NewOrderSingle msgs ..." << flush;
     unsigned snt(0);
-	while (_session.cached())
-	{
+    while (_session.cached()) {
         FIX8::TEX::NewOrderSingle *ptr(_session.pop());
-		if (!ptr)
-			break;
+        if (!ptr) break;
         send_msg(ptr, _session);
-		if (++snt % update_count == 0)
-		{
+        if (++snt % update_count == 0) {
             cout << '\r' << snt << " NewOrderSingle msgs sent       ";
             cout.flush();
         }
@@ -563,23 +562,17 @@ bool MyMenu::send_all_preloaded()
 }
 
 //-----------------------------------------------------------------------------------------
-bool MyMenu::send_all_preloaded(coroutine& coro, FIX8::Session *ses)
-{
+bool MyMenu::send_all_preloaded(coroutine &coro, FIX8::Session *ses) {
     unsigned snt(0);
     FIX8::TEX::NewOrderSingle *ptr;
 
-	reenter(coro)
-	{
+    reenter(coro) {
         ses->get_connection()->set_tcp_cork_flag(true);
-		while (_session.cached())
-		{
-			if (ses->get_connection()->writer_poll())
-			{
-				if (!(ptr = _session.pop()))
-					break;
+        while (_session.cached()) {
+            if (ses->get_connection()->writer_poll()) {
+                if (!(ptr = _session.pop())) break;
                 send_msg(ptr, _session);
-				if (++snt % batch_size)
-					continue;
+                if (++snt % batch_size) continue;
             }
             ses->get_connection()->set_tcp_cork_flag(false);
             coro_yield;
@@ -590,24 +583,20 @@ bool MyMenu::send_all_preloaded(coroutine& coro, FIX8::Session *ses)
 }
 
 //-----------------------------------------------------------------------------------------
-bool MyMenu::preload_new_order_single()
-{
+bool MyMenu::preload_new_order_single() {
     cout << endl;
     if (_session.size())
         cout << _session.size() << " NewOrderSingle msgs currently preloaded." << endl;
     unsigned num(preload_count);
-	if (!num)
-	{
+    if (!num) {
         cout << "Enter number of NewOrderSingle msgs to preload:";
         cout.flush();
         _tty.unset_raw_mode();
         cin >> num;
         _tty.set_raw_mode();
-	}
-	else
+    } else
         cout << "loading..." << endl;
-	for (unsigned ii(0); ii < num; ++ii)
-	{
+    for (unsigned ii(0); ii < num; ++ii) {
         static unsigned oid(10000);
         ostringstream oistr;
         oistr << "ord" << ++oid << '-' << num;
@@ -615,8 +604,11 @@ bool MyMenu::preload_new_order_single()
         perf_metric_start(performance_metrics::msg_create);
         FIX8::TEX::NewOrderSingle *ptr(new FIX8::TEX::NewOrderSingle);
 
-		*ptr  << new FIX8::TEX::Symbol("BHP")
-				<< new FIX8::TEX::HandlInst(FIX8::TEX::HandlInst_AUTOMATED_EXECUTION_ORDER_PRIVATE_NO_BROKER_INTERVENTION)
+        *ptr
+            << new FIX8::TEX::Symbol("BHP")
+            << new FIX8::TEX::HandlInst(
+                   FIX8::TEX::
+                       HandlInst_AUTOMATED_EXECUTION_ORDER_PRIVATE_NO_BROKER_INTERVENTION)
             << new FIX8::TEX::OrdType(FIX8::TEX::OrdType_LIMIT)
             << new FIX8::TEX::Side(FIX8::TEX::Side_BUY)
             << new FIX8::TEX::TimeInForce(FIX8::TEX::TimeInForce_FILL_OR_KILL)
@@ -637,8 +629,7 @@ bool MyMenu::preload_new_order_single()
 }
 
 //-----------------------------------------------------------------------------------------
-bool MyMenu::help()
-{
+bool MyMenu::help() {
     get_ostr() << endl;
     get_ostr() << "Key\tCommand" << endl;
     get_ostr() << "===\t=======" << endl;
@@ -649,17 +640,14 @@ bool MyMenu::help()
 }
 
 //-----------------------------------------------------------------------------------------
-bool MyMenu::do_logout()
-{
-	if (!_session.is_shutdown())
-		_session.send(new FIX8::TEX::Logout);
+bool MyMenu::do_logout() {
+    if (!_session.is_shutdown()) _session.send(new FIX8::TEX::Logout);
     FIX8::hypersleep<FIX8::h_seconds>(2);
     return false;  // will exit
 }
 
 //-----------------------------------------------------------------------------------------
-void print_usage()
-{
+void print_usage() {
     UsageMan um("hftest", GETARGLIST, "");
     um.setdesc("hftest -- f8 HF test client/server");
     um.add('s', "server", "run in server mode (default client mode)");
@@ -669,8 +657,10 @@ void print_usage()
     um.add('c', "config", "xml config (default: hf_client.xml or hf_server.xml)");
     um.add('o', "once", "for server, allow one client session then exit");
     um.add('q', "quiet", "do not print fix output (default yes)");
-	um.add('b', "batch", "if using batch send, number of messages in each batch (default 1000)");
-	um.add('p', "preload", "if batching or preloading, default number of messages to create");
+    um.add('b', "batch",
+           "if using batch send, number of messages in each batch (default 1000)");
+    um.add('p', "preload",
+           "if batching or preloading, default number of messages to create");
     um.add('R', "receive", "set next expected receive sequence number");
     um.add('S', "send", "set next send sequence number");
     um.add('r', "reliable", "start in reliable mode");
@@ -680,14 +670,13 @@ void print_usage()
 
 //-----------------------------------------------------------------------------------------
 //-----------------------------------------------------------------------------------------
-bool hf_session_client::handle_application(const unsigned seqnum, const FIX8::Message *&msg)
-{
+bool hf_session_client::handle_application(const unsigned seqnum,
+                                           const FIX8::Message *&msg) {
     return enforce(seqnum, msg) || msg->process(_router);
 }
 
 //-----------------------------------------------------------------------------------------
-bool tex_router_server::operator() (const FIX8::TEX::NewOrderSingle *msg)
-{
+bool tex_router_server::operator()(const FIX8::TEX::NewOrderSingle *msg) {
     static unsigned oid(0), eoid(0);
     FIX8::TEX::OrderQty qty;
     FIX8::TEX::Price price;
@@ -703,8 +692,7 @@ bool tex_router_server::operator() (const FIX8::TEX::NewOrderSingle *msg)
     *er << new FIX8::TEX::OrderID(oistr.str())
         << new FIX8::TEX::ExecType(FIX8::TEX::ExecType_NEW);
     unsigned ordResult(RandDev::getrandom(3));
-	switch (ordResult)
-	{
+    switch (ordResult) {
         default:
         case 0:
             *er << new FIX8::TEX::OrdStatus(FIX8::TEX::OrdStatus_NEW);
@@ -717,21 +705,17 @@ bool tex_router_server::operator() (const FIX8::TEX::NewOrderSingle *msg)
             break;
     }
 
-	*er   << new FIX8::TEX::LeavesQty(qty())
-			<< new FIX8::TEX::CumQty(0.)
-			<< new FIX8::TEX::AvgPx(0.)
-			<< new FIX8::TEX::LastCapacity('5')
+    *er << new FIX8::TEX::LeavesQty(qty()) << new FIX8::TEX::CumQty(0.)
+        << new FIX8::TEX::AvgPx(0.) << new FIX8::TEX::LastCapacity('5')
         << new FIX8::TEX::ReportToExch('Y')
         << new FIX8::TEX::ExecTransType(FIX8::TEX::ExecTransType_NEW)
         << new FIX8::TEX::ExecID(oistr.str());
     perf_metric_stop(performance_metrics::msg_create);
     send_msg(er, _session);
 
-	if (ordResult == 0)
-	{
+    if (ordResult == 0) {
         unsigned remaining_qty(qty()), cum_qty(0);
-		while (remaining_qty > 0)
-		{
+        while (remaining_qty > 0) {
             unsigned trdqty(1 + RandDev::getrandom(remaining_qty));
             remaining_qty -= trdqty;
             cum_qty += trdqty;
@@ -744,7 +728,9 @@ bool tex_router_server::operator() (const FIX8::TEX::NewOrderSingle *msg)
             *ner << new FIX8::TEX::ExecID(eistr.str())
                  << new FIX8::TEX::OrderID(oistr.str())
                  << new FIX8::TEX::ExecType(FIX8::TEX::ExecType_NEW)
-					<< new FIX8::TEX::OrdStatus(remaining_qty == trdqty ? FIX8::TEX::OrdStatus_FILLED : FIX8::TEX::OrdStatus_PARTIALLY_FILLED)
+                 << new FIX8::TEX::OrdStatus(
+                        remaining_qty == trdqty ? FIX8::TEX::OrdStatus_FILLED
+                                                : FIX8::TEX::OrdStatus_PARTIALLY_FILLED)
                  << new FIX8::TEX::LeavesQty(remaining_qty)
                  << new FIX8::TEX::CumQty(cum_qty)
                  << new FIX8::TEX::ExecTransType(FIX8::TEX::ExecTransType_NEW)
@@ -758,11 +744,9 @@ bool tex_router_server::operator() (const FIX8::TEX::NewOrderSingle *msg)
 }
 
 //-----------------------------------------------------------------------------------------
-bool tex_router_client::operator() (const FIX8::TEX::ExecutionReport *msg)
-{
+bool tex_router_client::operator()(const FIX8::TEX::ExecutionReport *msg) {
     static int exrecv(0);
-	if (++exrecv % update_count == 0)
-	{
+    if (++exrecv % update_count == 0) {
         cout << '\r' << exrecv << " ExecutionReport msgs received   ";
         cout.flush();
     }
@@ -770,8 +754,7 @@ bool tex_router_client::operator() (const FIX8::TEX::ExecutionReport *msg)
 }
 
 //-----------------------------------------------------------------------------------------
-bool hf_session_server::handle_application(const unsigned seqnum, const FIX8::Message *&msg)
-{
+bool hf_session_server::handle_application(const unsigned seqnum,
+                                           const FIX8::Message *&msg) {
     return enforce(seqnum, msg) || msg->process(_router);
 }
-
